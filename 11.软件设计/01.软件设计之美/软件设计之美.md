# 软件设计之美 （极客时间-郑烨）



## 课前必读

### 01软件设计是什么？

我们现在思考这个问题，为什么我们需要软件设计呢？

​		在开发过程中，软件不是在一段时间内集中开发，一个星期然后再也不用管了。软件开发是需要多人，长期进行开发的，还有后续新的需求加进来。就比如说初代淘宝和现在淘宝是千差万别的。一个软件就像一个生命一样，是需要慢慢成长的，是一个长期的过程。 这样就会引发一个问题？我们面对长期变化和新增的需求，我怎么才能让我们的软件面对这些变化的需求，保证更好的成长而不至于**夭折**。这就需要我们良好的**软件设计**。



#### **核心的模型**

​		在思考一个问题：我们为什么需要开发软件？答案显而易见，解决问题（需求）。淘宝解决了可以通过网络购物的问题。解决问题的最终结果是一个可运行的交付物。 

​		软件设计在这个解决问题的过程扮演了什么角色。软件设计需求和最终解决方案的一个桥梁。根据需求构建合适的软件设计，根据软件设计构建解决解决方案，这个解决方案当前需求下更加健壮。

![img](image/a6920a1e9a4a8af9fe86b88f032cb820-16526846701902.jpg)

​		在软件开发过程中设计到许多成员，这时候我们需要建了一个统一的结构，比如，一个房子的布局，哪个地方是厨房，那个地方厕所，哪里是卧室，卧室里面有哪些结构（衣柜等），厨房里面的布局结构。 项目成员看到这样一个统一的结构就会项目有一个统一的认识。对应到软件中，我们可以理解成我们的软件的结构是什么样（软件的统一结构），有哪些模块，每一个模块功能是什么，每一个模块又包含那些模块（每一个模块又变成一个统一的结构）。

​		这一个个统一的结构就是就是**模型**，**软件设计就是构建出一套合适的模型**

模型可以是描述业务的各种实体，也可以是各种功能组件。软件的核心就是模型，软件就是用模型组合而成的。高层模型也是有底层模型组合而成的。模型有大有小，不同的层次罢了，一个个类可以是模型，一个个系统也是模型。

模型是软件设计的核心是模型，好的软件设计必定是拥有的好的模型，那么什么是好的模型呢？

​		就是我们常听到的，**高内聚，低耦合**。它带来了什么？让功能抽离内聚到一个模块中，比如我们在开发功能的时候有时候需要通讯，我们就可以把通讯内聚到一个通讯的模块中，尽最大限度隐藏实现细节。这样的话一个模块的实现改动对其他模块的影响可以降到最低。也让我们更加便于扩展。

​		还能降低开发门槛，一个新的程序只需关注他所设计到模块就可以，因为相关功能都以已经内聚到这个模块了。

模型也是分层的，大的模块是由小的模块都构建的，高层模块是由下层模块进行构建的。类似于我们搭建乐高。由小的部件构建大的部件，由大的部件构建整个成品。

就是网络分层似的，应用层模型的通讯模块是由传输层提供的。

![img](image/bc7c736084e79d067477c306a9f5bb5a.jpg)

​			

在软件中，我们可以通过构建最核心的基础模型进行构建，然后通过这个模块在组合构建高层的模型。

举例：

​	交易系统---->分析交易动作---->	得到最基础的交易原语（交易动作中最基础的动作）：资产冻结、解冻、出金、入金----->交易动作可通过交易原语组合得到。

交易动作就是高层模型，交易原语就是底层模型

![img](image/b6432a9f6de195311674a8c0ac5a9c8d-16526869162815.jpg)

总结一下：

+ 模型是软件核心
+ 好的模型高内聚低耦合
+ 模型可以分层，底层模型提供接口，构建高层模型



#### **约束的规范**

构建模型的时候，一千个人构建的出来的都是不一样。如果一个项目里面不同一些规范，肯定是眼花缭乱的结构、各式各样的模型。

**规范，就是限定了什么样的需求应该以怎样的方式去完成**

+ 与业务处理相关的代码，应该体现在领域模型中；
+ 与网络连接相关的代码，应该写在网关里；
+ 与外部系统集成的代码，需要有防腐层；
+ 外部接口设计
+ 使用什么的操作数据库的框架



**常见规范问题：没有显示的规范**

+ 数据库访问，有用 `MyBatis` 的，有用 JDBC 的，也有用 Hibernate 的；
+ 外部接口设计，有用 REST 风格的，有用 URL 表示各种动作的；
+ 文件组织，有的按照业务功能划分（比如，产品、订单等），有的按照代码结构划分（比如，Resource、Service 等）；



**常见规范问题：规范不符合软件设计原则**

一个网关经常内存爆满，寻找原因是请求过来的JSON数据太过庞大，且有很多无用数据。转化成对象后对象太过庞大，占用过多的内存

解决方法：构建防腐层，在防腐层中吧请求的来的JSON转化成内部小对象。

这就是原来的设计规范不符合设计原则导致的

#### 模型与规范

​		那模型与规范是什么关系呢？模型与规范，二者相辅相成。一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型（规范的指定也要根据模型的特点，比如上面的网关层的设计）。

#### 	总结

+ 模型：软件骨架，粒度可大可小，好的模型高内聚低耦合，模型是分层的，高层模型是由底层的模型构建的
+ 规范：构建模型得按照规范来，对于长期维护至关重要。两个常见问题：缺乏显示统一的规范、规范不和设计原则
+ 模型与规范：二者相辅相成，互相依赖

![img](image/038f4e3e01a9cdd4d40ccf37e6771558-16526884983287.jpg)



#### 精彩评论



```tex
段启超：
防腐层是模型的一个规范，分享下我对防腐层的认知：
我接触防腐层的概念是从DDD的限界上下文开始的。Eric用细胞膜的概念来解释“限界”的概念，细胞膜只让细胞需要的物质进入细胞，同样，我们的代码之间业务也存在这个样一个界限，同一个对象的业务含义在不同的上下文中是不一样的。以在网上买书为例，在购买页面，我们的关注点在于这本书的名称，作者，以及分类，库存等信息；提交订单后，这本书就成为了订单上下文中的一个订单item，我们会关注这个item 的数量以及购买他的人是谁，以及书的配送地址等； 订单提交给仓库后，仓库会关心这本书还有没有库存，以及打包状态，分拣，物流等状态。
防腐层是在限界上下文之间映射（说白了就是交互）的方式，体现在代码上就是一个对象的转换，这个转换的意义在于隔离变化，防止因为对象在一个上下文中的变化扩散到其他的上下文中。

关于规范：
规范也是团队文化中很重要的一部分，以持续集成为例子，它的执行严格依赖于团队的开发纪律文化，以为了所谓赶进度而单元测试覆盖很低或者直接不写；采用分支策略方开发，一星期都合并不了主干，类似的人到处倒是，也就因为这一点，很多团队都在持续集成这个环节上掉队了。所以开发规范真的很重要，时刻谨记：混乱始于没有规范。

作者回复: 非常好的补充！
```





```tex
西西弗与卡夫卡
业务讨论之后进行领域设计，画出出静态模型（包括子系统、模块等）和动态结构（交互等），或者先勾勒接口（内内外系统的区隔），再做模型。实际过程有很多反复，并且会进行角色代入，看模型能否支持业务，直到模型比较稳定

作者回复: 你们做得很好
```

参考规范



```tex
光明
简单一点的项目，成员相互讨论（主要讨论业务场景和流程），内心会意即可。
复杂一点的项目，设计一般落脚在粒度较粗的文档上，往往也以说明业务流程为主，很少对实现过程中的细节文档化。
所以，我们的项目设计，模型一般会被业务场景和流程替代。文中的「模型」和「规范」，更多取决于工程师了。。。

作者回复: 对，你说的确实符合大部分做设计的方式。这种设计的关注点在于实现功能，而非构建模型。
这种做法容易让人忽略掉哪个东西是核心的，是模型，还是流程。流程是容易调整的，而模型如果变了，这个软件整个就变了。做设计的关键是，找到不变的东西。
```

模型是不容易变得的东西，所以我们应该把更多关注点放到构建模型上。这样一旦发生改动对系统影响最小。





### 02 分离关注点：软件设计至关重要的第一步



设计系统的时候或者解决问题的时我们一般采用的分而治之的方法。

​		在设计的过程中，分解比组合更加重要。一般我们首先知道最终的要什么样的东西，所以我们在软件设计的过程中更加关注对这个东西是怎么分解的。分解完之后我们就会知道怎么组装的了。

​		我们一般在分解的过程就只分解：系统 ，划分各个模块，都是按照大的功能（比如只按照这个软件的客户需求业务功能进行划分，没有抽离一些细小的技术"功能"，下面例子有体现）划分。在多少的情况下，我们分解的粒度会太大，导致一个模型下混杂着不同的东西(耦合到一块了)，为日后开发埋下了隐患。

#### 失败的分解案例

现在，我们举一个失败的分解案例

清结算系统

+ 上游系统推送消息到此系统
+ 上游系统推送来的消息是由结算系统发出去的（初始数据），有记录的
+ 问题：上游系统发送到此系统会出现丢消息的情况

初始的解决方案:

设计一个补偿模式，因为本系统是含有这些消息的初始数据，在数据库里增加一个状态，表示是否收到消息了。一旦发现丢了消息就会访问上游系统，重新推送

初始版本问题：

+ 在业务量大的情况下，丢失消息概率增加，设置的补偿机制会频繁的访问数据库，业务量同时也会增加访问数据库。这样的话系统必然卡顿。
+ 什么原因导致上面的问题呢？通信层面的问题混入到了业务层面上

丢消息从模型分析的角度来说与业务是没有关系的。开发人员在分解的过程中只考虑了功能上的维度，并没有考虑到其他维度的事情。技术和业务混在一起。就会导致了无穷无尽后患。

优化后版本:

丢消息为通信层面的问题，通讯层面的问题，通信层面解决。

选择一个吞吐量大的消息队列，**通信层面的问题在通信层面解决了，业务层面也就不会受到影响了**。

#### 分离关注点

上面的案例已经体现出分解粒度过大导致的问题

我们传统上在做设计的时候，经常就会根据以软件需求功能进行分解，以树形的方式。

![img](image/d439cc19ef775ea53b7809737609f59b.jpg)

这样会忽略很多隐形的模型，上面的错误案例就是一个非常好的案例，如果想要做出一个好的分，解就不仅仅要考虑功能性的需求，还要考虑非功能性的需求。

​	这些非功能需求和业务功能不是同一维度的，我们在设计的过程中要关注这些到不同的维度，每一个维度就是一个关注点，我们要学会分离这些关注点。（当然由高层维度和底层维度，维度里还能划分不同维度）。

​	有很多的关注点，我们在设计的过程中一定要注意识别关注点，如果识别不出来就会导致混淆，把两个关注点混淆到一块。**最常见的是把业务和技术混在一起**

​	再举一个反例，当我们先提升某一块的功能，我们首先想到是多线程。就直接把多线程一系列的东西，写到了这一块相关的代码中。这样就会导致技术和业务混合。这明明两个关注点。我们应该把多线程处理和业务处理分开。到时候我们直接调用多线程的相关框架就好。

**任何试图用技术去解决其他关注点的问题，只能是陷入焦油坑之中，越挣扎，陷得越深。**上面就是用多线程的技术，解决业务执行慢的问题，直接归并为一个关注点，这是不合理的。

​		还有一个关注点比较容易造成混淆，就是**数据的变动方向**，其实不同的方向应该是不同的关注点。

使用`Sping Data JPA`好还是`Mybatis`呢？JPA适用于简单的数据库的增删改查，Mybatis比较是用于复杂的查询。当我们纠结使用哪一个的时候，可能我们软件设计出现了问题，我们没有把上面两种情况进行分离开，混淆在一起了。当我们可以分离的时候，纠结也就不复存在了。

不同的数据变动方向还有很多，比如：

+ 动静分离，就是把变和不变的内容分开；
+ 读写分离，就是把读和写分开；
+ 前面提到的高频和低频，也可以分解开；

**不同的数据变动方向，就是一个潜在的、可以分离的关注点。** 也不一定非得必须分离，根据自己项目而决定。



宏观层面我们使用到分离关注点，微观同样适用。在设计类的时候有些时候我们不必setter方法，因为在这个关注点中不包含这个。比如某个配置类只在生成的对象时候加载一个复杂配置的文件（比如pfx文件），生成对象。并不能重新设置里面属性的值。只能使用get一些解析出的值

#### 总结

**分离关注点，发现的关注点越多越好，粒度越小越好**。

![img](image/46fb9a7cd6daac77dde4ffb6d28b7bc5-16527133079802.jpg)





#### 思考题

CQRS（Command Query Responsibility Segregation） 分离了那些关注点，适用于那些情况使用



#### 精彩评论

```tex
Jxin
1.cqrs，命令与查询分离，最早是在ddd实战里面看到。其分离啦增删改与查询这两个关注点。

2.静态上，拆分了这两块的代码。使各自可以采用不同的技术栈，做针对性的调优。动态上，切分了流量，能够更灵活的做资源分配。

3.查询服务的实现。可以走从库，这有利于降低主库压力，也可以做到水平扩展。但需要注意数据延迟的问题。在异步同步和同步多写上要做好权衡。
也可以都走主库，这时候查询服务最好能增加缓存层，以降低主库压力，而增删改服务要做好缓存的级联操作，以保证缓存的时效性。
当然也可以走非关系型数据库，搜索引擎类的es,solr，分布式存储的tidb等等，按需选择。

作者回复: 非常棒的分享！
```

分离关注点很好的例子



```tex
想起Kent Beck 说的一句话，大致意思是：我不准备在这本书里讲高并发问题，我的做法是把高并发问题从我的程序里移出去
作者回复: 没错，就是这样。
```

分离关注点很好的比喻。



```tex
我发现大家在工作中往往不做分离，分析需求的时候把方案揉在一起。
可以怎样去练习做分离呢？
作者回复: 有一种从小事练起的方法，就是写代码时，把自己写的函数行数限定在一定的规模之下，比如，10行。超过10行的代码，你就要去仔细想想是否是有东西混在了一起。

这种方法锻炼的就是找出不同关注点的思维习惯，一旦你具备了这种思维习惯，再去看大的设计，自然也会发现不同的关注点。
```

值得借鉴的实操方法，警示自己，是否没有分离关注点。





```tex
小学一年级
郑老师  我有个需求描述下（类比）： 用户购买网站会员  
我目前的设计用了两张表 
一张表存储用户购买会员的所有记录， 
另一张表 存当前的会员信息 (主要是  开始，结束时间，没有会员等级之类)  单独设计这张表的目的是为了sql关联查询方便，不用再判断是否过期。
但有个问题：我要用定时器一直扫这表，等会员过期了要删除记录。
请问郑老师 我这么做的问题在哪？ 更好的解决方式应该是什么？如果做到更细维度的拆分？



作者回复: 首先，你的描述没有把业务和实现分清楚。

你的业务是实现一个会员系统，具体到这里，是判断用户当前是否是会员。更具体一点的话，会涉及会员购买，主要是会员时间要延长，还会涉及到会员资格的判断，也就是当前用户是否是会员。

基于这些内容的判断，可以有不同的实现。根据你当前的实现，可以这样做：
* 购买会员，如果会员信息不存在，则添加会员信息，如果会员信息存在，则修改会员结束时间。
* 会员资格判别，根据用户 ID 和当前时间是否在时间范围内查询查询，如果记录存在，则是会员，否则不是。

结合你提供的信息，可以考虑的点是：
* 购买会员时，可以产生会员购买记录，此记录仅供后续查询使用；
* 只有当会员信息表过大时，才考虑是否需要删除。

在这个实现中，把购买和会员信息分开，把会员信息是否生效与记录是否删除分开了。

以上仅仅是根据你提供的信息进行的分析，如有不当之处，欢迎继续讨论。
```



```tex
技术和业务混杂的情况，让我想起来一篇文章，大意是说要区分技术异常和业务异常的。也就是说，技术层面的异常信息不应该暴露给上层的业务人员。典型的例子就是大型网站的错误页面，而不是直接把后台的npe堆栈信息抛给用户。
作者回复: 这是一个很好的例子，确实要做区分。
```





### 03 可测试性，一个影响测试的重要元素



​		在软件开发中，那一步最浪费时间。那就是集成测试。我们整体写完代码后，才进行整体测试或和其他几个系统联合测试。往往由于一个小的bug，影响几个系统，而且排查时间比较耗费时间。这种小小简单bug，能不能在整体测试的时候避免呢？因为整体测试涉及资源众多，人员部门也较多。排查问题及其耗费时间，往往还是简单bug导致的。

​		要想解决，就得在我们自己的小功能模块完成的时候测试出来。这就需要我们进行单元测试。但是我们有时候设计的时候，没有考虑到**可测试性**，有些小的模块可能不容易进行测试。**前期设计时就埋下了隐患，根本没有考虑“可测试性”。**



#### 软件设计要考虑“可测试性”

​	软件开发是干什么解决问题，解决问题就是需求，需求分为两大类一类是功能性需求、一类是非功能需求。功能性需求就是直面这些问题的分析出来的需求。

​		非功能性需求分为两大类，一类是执行质量，比如吞吐、延迟、安全，这一类是运行的时候通过运维手段所观察到的，另一类是演化质量，内含于软件结构中	比如测试性、可维护性、可扩展性。

![img](image/a126ab6ed0251c82b7d15c2e9c041cda-16527541918352.jpg)

演化质量就需要我们在软件设计中进行考虑，但是我们经常忽略他，尤其是可测试性。

​		可测试性为什么如此重要？就像开头所提到的，经常由于某一个模块简单的bug导致整个测试过程重新再来一遍，成本耗费是巨大的。就像盖房子，我们首先得保证钢筋、水泥这些质量，才进行大房子的质量的保证。一步一步来的。

​		从小的模块保证正确性，来大的模块做正确性作保障，把问题解决在最初的阶段，这样就保证后面的测试成本降低，因为越到后面简单的bug会导致昂贵的成本。所以在设计过程中我们尽可能考虑可测试性。

​		如果可测试性考虑不到位，就就会引发后续问题。比如，如果是复杂的系统会增加测试难度，在集成、部署等各个环节，都有其复杂性，也会增加其难度，完成一次部署往往也需要很长时间，资源成本昂贵，如果出现问题的话，定位问题也会由昂贵的成本。

​		为什么会在集成测试的时候浪费那么多时间呢，因为一些小的简单的问题应该在前面阶段暴漏（比如单元测试阶段），但是可测性考虑的不足导致，导致这些问题暴漏在集成测试阶段，耗费成本昂贵。

​		大部分程序员因为不好测原因，把一些功能测试留到集成测试的阶段。为什么不好测呢？设计的时候，没有考虑可测试性因素。那么如何在设计中考虑可测试性呢？**其实就是要在设计时想一下，这个函数 / 模块 / 系统要怎么测。**

​		**我们在设计一个函数 / 模块 / 系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖。**

怎么做？

+ 给每一模块尽可能多的测试，减少出错误概率，使其保持稳定
+ 尽可能搭建本地系统环境，周边系统采用模拟服务的方案

软件开发过程中考虑测试，实际上是思考软件的质量问题，而把质量的思考前移到开发，甚至是设计阶段，是软件开发从传统进入到现代的重要一步。



#### 有了测试视角设计

我们使用可测试性，来评判设计模式中的单例模式，**Singleton**。构造函数私有，无法继承，无法模拟。从可测试的角度不是一个好的设计模式。

TDD，就是测试驱动开发，大多数人不知道怎么写是因为不习惯写测试，和不知道怎么写测试。

举个没有考虑测试的例子

```java

class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository = new ProductRepository();
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```



这里我们要测试时候就需要，连接数据库。因为这个数据连接查询的在模块内部生成，无法模拟。连接数据的话这就更佳复杂没资源也就耗费变大。所以这并不是好的可测性的设计。

经过改造后

```java

class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository;
  
  public ProductService(final ProduceRepository repository) {
    this.repository = repository;
  }
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```

这个很明显我们可以注入一个模拟数据库连接的对象，这样就大大简化测试。可以顺利的完成单元测试。这就是考虑可测试性和不考虑可测试性之间的区别。

Spring比EJB有更好的可测试性。软件的发展趋势也和可测试性有相关性

#### **总结时刻**

设计的过程中经常忽略可测试性，导致很多模块无法在单独完成测试，只能被迫在集成测试阶段，我们在设计的过程中要尽可能考虑，**这个函数 / 模块 / 系统怎么测**。在开发中尽可能多的测试某一模块，使其在集成测试前变得比较稳定。

**做软件设计，请考虑可测试性**

#### 精彩评论

```tex
Michael
最近有同事正好在做PDF的生成，也就是把业务数据从各个别的服务拉取回来 然后清洗加工成自己想要的数据 然后传递给模版引擎进行渲染 最终生成pdf文件上传s3 然后通过API把上传的文件地址返回给客户端 想请问老师 这部分逻辑应该怎么测试？因为同事在写完代码之后只做了简单的测试（也就是直接mock其他的service的服务然后mock数据返回 以及mock了s3上传 ）最后只是简单看了一下返回值是否为空就完事了。最后到环境上验证才发现好多字段的格式有问题。那像这类场景我们该怎么合理测试才能尽可能保证做到测试完整性呢？
作者回复: 之所以我们要先讲分离关注点，就是因为很多人会把东西混在一起，测试当然就会很困难了。

以你的场景为例，做 PDF 生成，这里面要拆分开几个不同的环节：
* 从别的服务器拉取数据；
* 解析外部业务数据；
* 业务数据清洗成自己的数据；
* 采用模板引擎进行渲染生成 PDF；
* 将文件上传到 S3；
* 将文件地址返回给客户端。

接下来，就是一个一个分别构建这几个不同的模块，每个模块单独测试。
* 从别的服务器拉取数据：关注数据能否正确获取，获取出错该如何处理，这里需要将拉取协议进行隔离；
* 解析外部业务数据：关注数据能否正确解析，无法解析的数据该如何处理；
* 业务数据清洗成自己的数据：关注数据能否正确转化，业务含义不正确该如何处理；
* 采用模板引擎进行渲染生成PDF：关注渲染过程能否正常进行。需要将PDF作为一个生成目标进行隔离。这一过程需要人工检查生成的PDF格式是否正确。
* 将文件上传到S3：关注文件上传是否正确，需要将文件上传目标进行隔离，S3只是一个目标。
* 将文件地址返回给客户端：关注是否能够获取到文件地址，这里要结合上一项中的上传目标，将S3隔离开来。

各个都测试好之后，再进行集成测试，这里面的关注点就是这些模块联动起来是否能够正常运行，以及检查结果的正确性。
```

很好的案例：分离关注点+可测性设计



```tex
Moonus:
比如service层有个很长，包含复杂逻辑的private方法，但我又想测试他。只能通过最顶层的public方法作为入口，这导致需要保证大量的前提条件的正确，我们需要mock很多外部依赖。
当private方法复杂并包含逻辑，其正确应当重构代码，而不是在测试做妥协，可以将需要测试的private方法转移到另一个对象中，成为一个public的方法。同时让我体会到测试驱动设计的含义。
作者回复: private 方法怎么测？其实是一个伪命题。要测 private 方法，更多的是因为这个类承担了过多的职责，才会出现层层嵌套的方法，才会不好测。

你的改进方法非常对，将这个方法移到另外一个类中，它成了 public 的，该怎么测，就怎么测
```



```tex
段启超:
    和大家分享一下我最近发现的一个问题：滥用@Autowired
    最近在给手上的代码上加测试的时候我进行了如下操作：
    1. 我在测试类中写了一个测试，因为类A中要执行的这个逻辑需要依赖另外一个对象B，于是我把这个需要依赖的对象B从全局变量中移动到构造中，作为参数放了进去，然后再构造方法上加了注解@Autowired。（注意： 原来的这个@Autowired 是在这个全局变量上的）
    2. 我在测试中mock 了这个依赖的B对象，然后给到了这个Service 的实例中去。
    3. 写业务代码实现，让测试通过。 
     
    本来以为测试已经通过，没什么问题了，结果在集成测试启动Spring 容器的时候，发现挂掉了，发生了循环依赖，查看代码，果然，在B中也@Autowired 注入了A ，他们两个就此开始循环～～～～
    结果用idea 的分析工具扫了一通，发现循环依赖不止于此，还有很多很多。。。。。
   
  从这件事儿上体现出来的问题： 
  1:  滥用@Autowired 体现出来的首先就是没有分离关注点，让一个类中做了过多的事情。 现在想过来原来写过的很多代码里头都是一大堆的@Autowired 注入 ，很多XXXService 的代码大概率的会发生这种事情。 
  2:  其实IDEA 编译器里边早就提醒过你了，当你在字段上使用@Autowired 去注入的时候，会有黄线的提示，提醒你不要这么使用，推荐你使用构造器的方式去注入。而很多人的处理方式就是对这个黄线视而不见。 
  3：如果从代码的测试性的角度来出发，你一定不会这么做，因为这么做没有办法去mock 你的依赖。 代码会丑到你自己都不想看。 
  4:  以前没想过循环依赖是怎么发生的，现在明白了：一个罪魁祸首就是滥用@Autowired  。循环依赖本身也是一个设计上的坏味道。如果有人问我说如何解决循环依赖，我会回答他： 首先不要循环依赖。 
 
作者回复: 多谢分享如此惨痛的教训，相信你已经理解了循环依赖的问题所在。

从设计的角度看，循环依赖之所以产生，一个重要的原因就是没有分清接口和实现。如果都是实现，一不小心就循环依赖了，如果分清楚接口和实现，实现依赖于接口，产生循环依赖的可能性就会大幅度降低。
```

其实也是没有分离好关注点 ，分离好关注点尽可能少的出现循环依赖。还有就是要依赖接口，不要依赖实现。

为了可测试性---->构造方法注入---->虽然通过单元测试（都是模拟的假对象，不会发现循环依赖）--->正运行项目的时候发现循环依赖，导致项目奔溃。



```TEX
西西弗与卡夫卡
曾经开发过堆场应用，其中一个步骤是从远端服务器同步到本地服务器，然后再执行本地逻辑。如果每次测试本地逻辑都要从服务端拉取数据的话，就没法自动测了。当时采用的测试方法就是先抓取接口数据生成接口文件，测试就从文件中加载，再运行，最后销毁整个数据库。如果有接口相关的bug，也同样抓取数据保存，构建一个bug号命名的测试方法测试bug。

后来做过系统高可用软件，采用的方法是将代码自动部署到多个Docker里，测试代码里依据场景（为了方便，场景还用DSL写）比如杀某个Docker来测试高可用逻辑是否正常。
作者回复: 很赞的做法！
```



