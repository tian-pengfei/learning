# java基础

## 第一章 java基本程序设计结构

### 1.1数据类型

java数据类型和java对象的区别

|   类别   |                             区别                             |
| :------: | :----------------------------------------------------------: |
| 数据类型 |          没有引用的概念，就是表示存储在内存上的数据          |
|   对象   | 需要来用存储在栈上的引用类型来指向，对象本身存储在堆上，引用类型存储的对象的地址相当于c++的指针。（后面详细介绍jvm内存模型） |

八种基本类型

|  类别   |    存储需求    |                 | 备注                                                         |      |
| :-----: | :------------: | :-------------: | ------------------------------------------------------------ | ---- |
|   int   |     4字节      |      整型       |                                                              |      |
|  short  |     2字节      |      整型       | 常应用于底层文件的处理                                       |      |
|  long   |     8字节      |      整型       |                                                              |      |
|  byte   |     1字节      |      整型       |                                                              |      |
|  float  |     4字节      |      浮点       |                                                              |      |
| double  |     8字节      |      浮点       | 三个特殊的浮点类型：正无穷大、负无穷大、<br />、NaN(不是一个数字) |      |
|  char   |     16bit      | 表示Unicode编码 |                                                              |      |
| boolean | 1bit（不知道） |                 |                                                              |      |

### 1.2 变量

| 值得注意的几个地方                                           |
| ------------------------------------------------------------ |
| 1.不能使用未初始化的变量                                     |
| 2.变量的声明尽量靠经第一次使用的地方                         |
| 3.常量要用final关键字，常量名最好大写，一生只能被赋值一次 。static final 用来定义类常量。 |
| 4.const 目前是java的保留字还未使用，常量必须使用final来声明。 |

### 1.3运算符

+、-、*、 / % 分别表示 加、减、乘、除、取余  结果的数据类型为参数的数据类型的范围最大的那个

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

### 1.4 字符串

java无内置字符串，标准类库提供了预定义类String （官方已经定义好的,非原生）。

<font color="red" >**每个用双引号括起来的字符串都是String类实例**</font>

1. **不可变**

   根据String源码发现，String对象没有修改自己数值的方法，只有生成字符串对象的方法（不改变自身对象的值）。

2. **String 常量共享**

   什么是String常量？只要是只要是用双引好包裹表示就相当于生成一个String常量。比如 String a=new String("abc"); 其实是生成了两个字符串常量一个是“abc”字符串常量对象； 另一个是值为“abc”的String对象；虽然它们两个的值相等的，但是他们不是一个对象。

   看下面代码：

   ```java
   		String strA = "112";
           String strB = "112";
           String strC = new String("112");
           String strD = "11" + "2";
           String a="11",b="2";String strE=a+b;
           String strF=a+"2";
           System.out.println("strA==strB:"+(strA==strB));
           System.out.println("strA==strC:"+(strA==strC));
           System.out.println("strA==strD:"+(strA==strD));
           System.out.println("strA==strE:"+(strA==strE));
           System.out.println("strA==strF:"+(strA==strF));
   ```

   打印结果

   ```text
   strA==strB:true
   strA==strC:false
   strA==strD:true
   strA==strE:false
   strA==strF:false
   ```

我们先来搞清楚== 和equals

<font color="red">**值比较？地址比较？**</font>

​			== 就是值比较，不过比较的值是引用类型的值，引用类型的值是什么？就是所指向对象的地址。例如：String a= new String("abc") 就是都这个函数返回一个引用类型的值赋给了 引用类型a; 

​		equals方法是对象的方法，只不过引用类型可以调用，进而可以比较他们指向对象的值。还有一点需要注意equals比较对象之间的值是否相等是根据对象的特性来写的。

strA==strB:true  引用类型指向同一个常量String 。所以他们同一个对象。

strA==strC:false 两个不同的对象 new String()不做共享变量

strA==strD:true 通过反编译可以看到这种写法与strA strB没有任何区别

strA==strE:false String strF=a+"2"; 字符串拼接 只要里面含有一个非常量，他就会生成一个非常量的String



咱们再在探究一下 new String("123"); 先看下面这段代码。

```java
		 char [] a={'a','c','d'}; char[] b=a;
         b[0]='A';System.out.println(a[0]);
```

打印结果

```text
A
```

说明数组也是一个对象，也就是可以用引用类型来指向。

再来看一下String 的new String方法

```java
  	public String(String original) {
        this.value = original.value; // private final char value[]; 
        this.hash = original.hash;  //private int hash; 
    }
```

也就说 this.value 和original.value 引用的是同一个数组对象。 所以说original不管所表示的字符串多大，只要它存在this的生成速度是极快，和大小没有影响。

3. **String注意要点**

 contact方法

```java
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}
```

concat方法的本质是生成一个新的String，从两个字符串中一个一个复制。这种方法不适合使用在连续向超大型字符串上拼接字符串。因为它会一个一个字符的复制到新的字符串上，极度浪费时间。”abc................................“.concat("a")， 这样循环几次就会极度浪费时间。

```java
String a="abc......"//超大字符串
while(有限次){
    a=a.concat("a")
}
```



上面的代码在有限的时间内运行不了几次



a+b的本质什么？ StringBuilder有什么弊端？ 小心StringBuilder的扩容机制导致内存溢出

4. **码点和代码单元**



5.**常用API**

|                        签名                         |                             解释                             |
| :-------------------------------------------------: | :----------------------------------------------------------: |
|               char charAt (int index)               | 返回给定位置的代码单元。除非对底层的代码单元感兴趣，<br />否则不需要调用这个方法。 |
|             int codePointAt(int Index)              |                  返回从给定位置开始的码点。                  |
| int offsetByCodePoints(int startlndex, int cpCount) |   返回从 startlndex 代码点开始位移 cpCount 后的码点索引。    |
|            int  compareTo(String other)             | 按照字典顺序如果字符串位于 other 之前，返回一个负数；如果字符串位于 <br />other 之后，返回一个正数； 如果两个字符串相等，返回 0。 |
|               IntStream codePoints()                | 将这个字符串的码点作为一个流返回。调用 toArray 将它们放在一个数组中。 |
| new String(int[] codePoints, int offset, int count) |    用数组中从 offset 开始的 count 个码点构造一个字符串。     |
|            boolean equals(0bject other)             |             如果字符串与 other 相等，返回 true。             |
|                        ....                         |                            .....                             |
|                  查看核心技术卷一                   |                                                              |

### 1.5 输入输出

1. **读取输入**

输标准出流输出内容到控制台非常简单，System.out.println 即可。

读取标准输入流System.in，得用到Scanner对象与标准输入流相关联，例如：Scanner in = new Scanner(System.in); 然后利用Scanner类的方法进行读取

控制台读取密码不用Scanner 因为可见。用Console类来实现	

```java
//在控制台运行程序，要不Console为空
Console cons = System.console();
String username = cons.readLine("User name: ");
char[] passwd = cons.readPassword("Password:", new Object[0]);
```

输出结果：密码输入不可见

```text
User name: root   
Password:
```





> java.util.Scanner5.0 



| API                                                 | 说明                                           |
| --------------------------------------------------- | ---------------------------------------------- |
| Scanner (InputStream in)                            | 用给定的输人流创建一个 Scanner 对象            |
| String nextLine( )                                  | 读取输入的下一行内容。                         |
| String next( )                                      | 读取输入的下一个单词（以空格作为分隔符)        |
| int nextlnt( )<br />double nextDouble( )            | 读取并转换下一个表示整数或浮点数的字符序列。   |
| boolean hasNext( )                                  | 检测输人中是否还有其他单词 。                  |
| boolean hasNextInt( )<br />boolean hasNextDouble( ) | 检测是否还有表示整数或浮点数的下一个字符序列。 |

> java.Iang.System 1.0

static Console console( ) 

| API                       | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| static Console console( ) | 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个<br /> Console 对象，否则返回 null。 对于任何一个通过控制台窗口启动的<br />程序，都可使用 Console 对象。否则，其可用性将与所使用的系统有关 。 |

> java.io.Console 6

| API                                                          |                             说明                             |
| ------------------------------------------------------------ | :----------------------------------------------------------: |
| static char[] readPassword(String prompt, Object...args)<br />static String readLine(String prompt, Object...args) | 显示字符串 prompt 并且读取用户输入，直到输入行结束。 args 参数可以用来提供输人格式。 |

2.**格式化输出**

System.out.printf 方法可以进行格式化输出

System . out . printf（ ”8.2f“, x);

每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数

![image-20201125140838961](image/image-20201125140838961.png)

![image-20201125140544805](image/image-20201125140544805.png)

具体使用https://blog.csdn.net/jhsword/article/details/108574442



它是怎么解析这些字符串的，是通过Formatter类进行了解析，这个与String.format方法用的一个类进行的解析。我们在写程序的过程中可以适当借用这些预定义类进行功能的实现。

3.**文件的输入输出**

记住几个API

> java.util.Scanner 5.0

| API                  | 说明                                     |
| -------------------- | ---------------------------------------- |
| Scanner(File f)      | 构造一个从给定文件读取数据的 Scanner。   |
| Scanner(String data) | 构造一个从给定字符串读取数据的 Scanner。 |
|                      |                                          |

> java.io.PrintWriter 1.1

| API                              | 说明                                                      |
| -------------------------------- | --------------------------------------------------------- |
| PrintWriter(String fileName)     | 构造一个将数据写入文件的 PrintWriter。 文件名由参数指定。 |
| static Path get(String pathname) | 根据给定的路径名构造一个 Path。                           |

### 1.6 大数值

> Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。

对于c++得自己写大数值的计算，一般做算法题要求会会写简单的大数值的运算+ - * /

BigInteger 存在4000行代码，里面用到许多经典算法，值得后续研究。

### 1.7 数组

1. **支持Foreach循环**

   数组是支持foreach来遍历数组的值。实现Iterable的类对象也支foreach语法

   ```java
   for (variable : collection)  statement
   ```

   

2. **数组的初始化以及匿名数组**

   int[] a = new int[100];

   上面这种是创建了一个数组，存在了一个数组对象，被默认初始化。但是数组元素未必含有值。

   数字数组所有元素初始化为0；boolean数组初始化为false，对象数组初始化为了null

```java
Arrays.toString(a); //a为一个数组
```

若a 为基本数据类型的数组，就会以为一个数组元素的值组成字符串

若a为对象数组，就会调用对象的toString方法组成字符串

```java
new int[] { 17, 19, 23, 29, 31, 37 } //初始化匿名数组
```

```java
int [] a={17, 19, 23, 29, 31, 37 };
a=new int[] { 17, 19, 23, 29, 31, 37 }; 
a={17, 19, 23, 29, 31, 37 }; //报错
```

匿名数组的语法形式可以在不重新创建变量的情况下，可以重新初始化一个数组

与字符串一样 数组长度为0和null不相同

3.**数组拷贝**

在前面已经验证，数组也是一种object。也是需要引用类型来指向，所以拷贝数组的话不能使用"="，所以需要Arrays.copyOf()函数来进行深拷贝。

Array.copyof()可传入对象数组进行拷贝，它的原理是什么呢？

```java
@SuppressWarnings("unchecked")
public static <T> T[] copyOf(T[] original, int newLength) {
    return (T[]) copyOf(original, newLength, original.getClass());
}
```

```java
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    @SuppressWarnings("unchecked")
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
```

解释 说明



Arrays一些比较有用的API

> java . util.Arrays 1.2

| API                                                          | 说明 |
| ------------------------------------------------------------ | ---- |
| static String toString(type[]a)                              |      |
| static type copyOf(type[]a, int length)<br />static type copyOfRange(type[]a , int start, int end) |      |
| static void sort(type [ ] a)                                 |      |
| static int binarySearch(type[] a , type v)<br />static int binarySearch(type[]a, int start, int end , type v) |      |
| static void fill(type[]a , type v)                           |      |
| static boolean equals(type[]a, type[]b)                      |      |

4. **多维数组**

foreach同样可以嵌套使用 来访问元素

```java
for (double row : a)
	for (double value : row)
		do something with value
```

a为一个二维数组  则a[i]表示一个一位数组

```java
int[][] odds = new int[NMAX + 1] [] ;
for (int n = 0; n <= NMAX ; n++)
	odds [n] = new int[n + 1] ;
```

表示的不规则数组为

```text
0
0 0
0 0 0
0 0 0 0
0 0 0 0 0
.....
```

## 第二章 对象和类



### 2.1 面向对象设计

1. **类**

面向对象设计即OOP

对象的一个重要概念说就是封装（encapsulation），把对象的数据和行为组装到一个包，并对对象的使用者隐藏数据的实现方式。

实例域：对象中的数据     方法：操作数据的过程

封装的关键：不能让类中的方法直接访问其他类的实例域。

继承 更加便于定义自定义类，方便扩展。

2.**类之间的关系**

![image-20201125212726997](image/image-20201125212726997.png)

### 2.2 预定义类

1. **对象和对象变量**

对象变量不是一个对象，只是可以存储对象的引用，也就是引用一个对象。对象变量可以通过引用调用所引用的对象的方法。

局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。



2. **多使用官方的自定义类**

比如

> java.time.LocalDate 8

| API                                                          | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| static Local Time now( )                                     | 构造一个表示当前日期的对象。                                 |
| static LocalTime of( int year , int month , int day )        | 构造一个表示给定日期的对象。                                 |
| int getYear( )<br />int getMonthValue( )<br />int getDayOfMonth( ) | 得到当前日期的年、月和曰。                                   |
| DayOfWeek getDayOfWeek( )                                    | 得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到<br/>1 ~ 7 之间的一个数，表示这是星期几，1 表示星期一，7 表示星期日。 |
| Local Date piusDays( int n )<br />LocalDate minusDays(int n) | 生成当前日期之后或之前 n 天的日期。                          |

### 2.3 自定义类

1. **隐式参数和显示参数**

```java
//Employee类的一个方法
public void raiseSalary(double byPercent)  
{
    double raise = salary * byPercent / 100;
    salary += raise;
}

number007.raiseSalary(5);
```

 byPercent为显示参数， number007为隐式参数，在方法中this可以表示隐式参数。（this要与关键字super使用上做好区分）

2.  **final实例域**

final修饰的变量值是不允许改变的。

修饰基本类型的变量时，他表示的值是不会改变的。当它修饰对象变量时，对象变量的引用值是不会改变的，也即是说所引用的对象（如果是可变类对象）自身的值是可以修改的。

什么是不可变类对象----类中只有final修饰的基本类型域或者不可变类型对象。  

### 2.4 静态域与静态方法

### 2.5 方法参数

方法参数是按照值传递，对象参数则传递拷贝的引用值，基本类型参数则直接传递拷贝代表的值

### 2.6 对象构造

**重载（overloading）**：一个类里相同的方法名 不同的签名（参数的个数+参数的类型）。 下面这种调用就是重载

​	     StringBuilder messages = new StringBuilder();

​		 StringBuilder todoList = new StringBuilder("To do:\n")；



**默认域初始化**

​		构造器中没有显示的对域进行初始化会被自动地赋值，数值为0 、布尔值为false、对象引用为null

**无参数构造器**

​		编写类时，如果没有编写构造方法，会自动生成一个隐式 无参数构造方法。和下面操作的效果一样

```java
public Employee(){
}
```

**显示域初始化**

在执行构造方法之前进行赋值

```java
class Employee{
    private String name ="";
}

```

```java
class Employee{
    public Employee(String name){
        this.name=name;
    }
}
```

**初始化块**

```java
class Employee
{
    private static int nextld;
    private int id;
    private String name;
    private double salary;
	// object initialization block
    {
        id = nextld;
        nextld++;
    }
    public Employee(String n, double s){
        salary = s;
        name=n;
    }
}
	
```

初始化的执行顺序

1 ) 所有数据域被初始化为默认值（0、 false 或 null )

2 ) 按照在类声明中出现的次序依次执行所有域初始化语句和初始化块。

3 ) 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体

4 ) 执行这个构造器的主体。

**对象析构与 finalize 方法**

​	当回收对象的时候执行这个方法。当JVM回收一个对会判断对象是否覆盖这个方法，若没有覆盖直接回收。否则会把这个对象放入一个F-Queue队列，线程就会执行队列里面对象的finalize方法。执行后再次进行可达性分析判断是否回收。若不回收在直接复活。 finalize只会被系统调用一次

![img](image/16c6b138ec69932d)

### 2.7 包

**静态导入**

**包作用域**

### 2.8文档注释

### 2.9类设计技巧

| 一定保证的数据的私有                                         |
| ------------------------------------------------------------ |
| 一定要对数据的初始化，虽然java对对象的实例进行初始化（不对局部变量的初始化），最好不要依赖系统的默认初始化，而是要显示的对数据进行初始化 |
| 不要在类中使用过多的基本类型<br />private String street;<br/>private String city;<br/>private String state; <br />可以把上面这个几个变量封装成Address类，这样便于管理。 |
| 不是所有的域需要域访问器和域更改器--最大封装性防止数据被破坏 |
| 将职责过多的类进行分解 (一副扑克牌分解为 一副扑克牌和一张扑克牌) |
| 类名和方法名要能够体现它们的职责                             |
| 优先使用不可变类                                             |

## 第三章  继承



### 3.1 超类和子类

####  定义子类

```java
public class Employee
{
    // instance fields
    private String name ;
    private double salary;
    private LocalDate hireDay;
    // constructor
    public Employee(String n , double s, int year , int month , int day)
    {
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day) ;
    }
    // a method
    public String getName()
    {
        return name;
    }
    public double getSalaryO
    {
   	 	return salary;
    }
}
```



```java
public class Manager extends Employee
{
	private double bonus;
    public void setBonus(double bonus)
    {
 	   this.bonus = bonus;
    }
}
```

子类将拥有父类的所有的方法和域，在设计的时候应该将通用的方法放入到父类，将特殊用途的方法放到子类中

#### 覆盖方法

​	父类的方法并不一定适用于子类的使用，所以需要我们在子类里面进行方法重写的也就是覆盖父类实现的方法。覆盖只是对外部调用而言的，子类覆盖了父类的某一方法，子类中依然可以调用这个方法（它依然继承且拥有这个方法这是只能在类内部进行调用），用super.method()调用，因为需要标识否则会调用子类中重写的方法。

> super只有标识的作用,标识出在父类中声明的方法。而this指向的是当前对象

```java
public class Manager extends Employee
{
	private double bonus;
    public void setBonus(double bonus)
    {
 	   this.bonus = bonus;
    }
    
    public double getSalaryO
    {
    	//return salary + bonus; // won't work
         return super().getSalary() + bonus; // won't work
    }
}
```

在子类里面是无法访问到salary，因为他是在父类中声明并且是私有的，子类中是不能访问。也可以这么理解子类拥有这个域，但是不能直接访问。

#### 子类构造器

由于 Manager 类的构造器不能访问 Employee 类的私有域，所以必须利用 Employee 类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用

```java
//显示调用的方法
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day) ;
    bonus = 0;
}
```

​		非静态类，都会有构造器。子类构造器一定会调用父类的构造器，如果不显示调用父类构造器就会隐式调用父类的默认构造器（无参数的构造器），如果父类没有默认的构造器就会报错。

![image-20201210214756365](image/image-20201210214756365.png)

![image-20201210214245690](image/image-20201210214245690.png)





|  |  |
| ----- | ------------------------------------------ |
| this |        1.引用隐式参数<br />2.调用该类的其他构造器                                    |
| super | 1.调用超类的方法<br />2.调用超类的构造器 |

####  多态

​	对象变量是多态，父类对象变量可以引用子类对象实例。 一个 Employee 变量既可以引用一个Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象（例如：Manager）。但是不能将一个超类的引用赋给子类变量。这样会导致错误。 

#### 理解方法的调用

从编译器和虚拟机的角度解释调用x.f(args)的过程（x可能是一个声明的变量，也可能是this,或者隐式的this）

① **找出所有的候选方法：**编译器根据x的声明的类型，假设为C类型，找出C类型所有名字f的方法和父类名字为f的方法并且是public的访问权限。

② 编译器根据传入的参数的对象的类型找到适合的方法，这个过程包括参数的类型自动转化。（现在我们已经确定调用的方法的方法名和签名）-------这里只是确定将要调用的方法样式，并不是一定调用当前这个。

③如果找到的这个方法是private static finnal 那么编译器肯定会调用的是上面的找到的那个方法。

不知道大家发没发现上面是在编译期间的工作室，如果在第三步编译器就能找到确切的执行哪个方法就不用在运行的时候确定了。 所以叫**静态绑定**



④ 如果不是上面的方法修饰符，那就不一定是我们找到的那个方法。所以虚拟机只能在运行的时候去确定到底执行哪个方法。虚拟机会预先为每个类创建方法表。虚拟机直接查这个表就行。假设x指向的是D类对象（C类的子类），直接搜寻这个D类的方法表（方法表里面的方法不一定都是在D类中声明的方法也可能是在的C类中声明）

下面是Employee和Manager的方法表

![image-20201211224627955](image/image-20201211224627955.png)

![image-20201211224547732](image/image-20201211224547732.png)



第四步是动态绑定无需现有代码进行修改就可对代码进行扩展，比如新增增一个C的子类 E    C类引用就可以指向E并且可以调用E类中的某些方法



#### final

|             |                                                              |
| ----------- | ------------------------------------------------------------ |
| final修饰类 | 这个类不能被继承                                             |
|    final方法       | 这个方法不能被子类重写                                       |
|   final修饰引用变量    | 修饰引用表示这个 引用值不能改变，也就是一直引用这个对象不能改变 |
|    final修饰基本类型     | 修饰基本类型表示这个这个变量表示值不能被改变                 |

​	final类型的数据若在定义时没有显示初始化，是没有默认初值的。 对于在定义时没有显式初始化的，应该在构造方法中进行初始化.并且final修饰的数据一生只能初始化一次

#### 强制类转换

#### 抽象类

#### 受保护的访问

### Object所有类的超类

​		所有的类更具继承关系往上追踪都是Object对象，在java里面它是所有类的始祖。如果没有指出某个类的父类，那么这个类就继承于Object类。所以object类的变量可以引用任何类型的对象。

> **Object类是所有类的始祖，任何类都拥有Object中定义的方法**

我们现在简单看一下Object类里面定义了哪些方法

#### equals方法

> equals(Object obj)

这里值判断了两个对象引用是否具有相同的引用(this引用变量与传入的值的值比较。

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

每个对象都有一个隐式参数，一个指向自己的变量 this)因为每一个类的相等含义不相同，所以一般都会重写这个方法。但是重写的时候也不是随便的重写的，要不会造成不必要的麻烦遵循以下原则

| 准则   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 自反性 | x.equals(x) 必须返回true                                     |
| 一致性 | x.equals(y)  x与y所指向的对象只要不被改变，并且x y 指向不改变。x.equals(y)无论被调用多少次它结果也不会被改变 |
| 传递性 | x.equals(y) 与y.equals(z)结果一致。那么 x.equals(z)的结果与他们一样 |
| 对称性 | x.equals(y) 与y.equals(x)结果一致                            |
| 其他   | x.equals（null）永远返回false；<br/>For any non-null reference value  ` x`,    `x.equals(null)`  should return  `false`. |

还有一点需要注意那就是

> 重写了equals方法必须重写hashcode方法，因为两个相等的对象hash codes
>
> ```java
> /**
> *Note that it is generally necessary to override the {@code hashCode}
> * method whenever this method is overridden, so as to maintain the
> * general contract for the {@code hashCode} method, which states
> * that equal objects must have equal hash codes.*/
> ```



#### hashcode方法

>  public native int hashCode();

```java
public native int hashCode();
```

​	顺便说一下带有native关键字的方法。这样的函数为原生函数，这个方法相当于是接口调用有其他语言实现的方法。比如c语言实现的方法。这些语言编写的方法会被编写成动态链接库文件（dll），由我们的直接去调用使用。

```java
/*As much as is reasonably practical, the hashCode method defined by
* class {@code Object} does return distinct integers for distinct
* objects. (This is typically implemented by converting the internal
* address of the object into an integer, but this implementation
* technique is not required by the
* Java&trade; programming language. */
```

 这个hashCode()方法默认是由对象的地址转换而来的

有些情况需要与系统底层进行一些交互，由于java是跨平台牺牲了一些对底层的控制。所以需要借助其他语言一些协助。详情内容参考 <a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">这里</a>



hashCode()有以下通用约定，也就是我们重写这个方法需要注意的地方。为什么需要注意呢？因为有许多的地方调用了hashcode这个方法比如HashMap这个类的对象在存储的时候就利用到了要存储的对象的hashcode方法。不能影响规则。

```java
/**
* <p>
* The general contract of {@code hashCode} is:
* <ul>
* <li>Whenever it is invoked on the same object more than once during
*     an execution of a Java application, the {@code hashCode} method
*     must consistently return the same integer, provided no information
*     used in {@code equals} comparisons on the object is modified.
*     This integer need not remain consistent from one execution of an
*     application to another execution of the same application.
* <li>If two objects are equal according to the {@code equals(Object)}
*     method, then calling the {@code hashCode} method on each of
*     the two objects must produce the same integer result.
* <li>It is <em>not</em> required that if two objects are unequal
*     according to the {@link java.lang.Object#equals(java.lang.Object)}
*     method, then calling the {@code hashCode} method on each of the
*     two objects must produce distinct integer results.  However, the
*     programmer should be aware that producing distinct integer results
*     for unequal objects may improve the performance of hash tables.
* </ul>
* <p> 
*/
```

| 通用约定                                                     |
| ------------------------------------------------------------ |
| 只要equal方法中用到的信息没有被修改，不管调用多少次此方法返回的数值是不变的 |
| 两个对象通过equals返回true，两个对象的执行此方法返回的数值是一样的即hashcode一样 |
| 不相等的对象不要求一定得产生不同的数值，但是不同对象的hash值会提高hash的性能（可能减少了hash冲突） |

#### toString方法

这个方法的作用就是返回对象的一些信息。来能标识出这个对象。

```java
 /**Returns a string representation of the object. */
```

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

根据我们的自己定义的类相应的重写这个方法再打印一些信息的时候能使我们更加认识对象的内容，尤其是在调试过程中能把关键的信息提取出来

#### 





















| 方法名             | 作用 |
| ------------------ | ---- |
| equals(Object obj) |      |
|                    |      |
|                    |      |
|                    |      |
|                    |      |



### 泛型数组

### 装箱拆箱

### 参数数量可变方法

### 枚举类

### 反射

### 继承的设计技巧

## 第四章 接口、lambda表达式和内部类

### 4.1接口

### 4.2 接口示例

### 4.3 内部类（静态内部类 普通内部类 匿名内部类）

### 4.4 代理

## **第五章 异 常 、 断 言 和 曰 志**



## 第六章 泛型程序设计

## 第七章 集合

### 第八章 并发基础使用

