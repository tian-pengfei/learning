# java基础

## 第一章 java基本程序设计结构

### 1.1数据类型

java数据类型和java对象的区别

|   类别   |                             区别                             |
| :------: | :----------------------------------------------------------: |
| 数据类型 |          没有引用的概念，就是表示存储在内存上的数据          |
|   对象   | 需要来用存储在栈上的引用类型来指向，对象本身存储在堆上，引用类型存储的对象的地址相当于c++的指针。（后面详细介绍jvm内存模型） |

八种基本类型

|  类别   |    存储需求    |                 | 备注                                                         |      |
| :-----: | :------------: | :-------------: | ------------------------------------------------------------ | ---- |
|   int   |     4字节      |      整型       |                                                              |      |
|  short  |     2字节      |      整型       | 常应用于底层文件的处理                                       |      |
|  long   |     8字节      |      整型       |                                                              |      |
|  byte   |     1字节      |      整型       |                                                              |      |
|  float  |     4字节      |      浮点       |                                                              |      |
| double  |     8字节      |      浮点       | 三个特殊的浮点类型：正无穷大、负无穷大、<br />、NaN(不是一个数字) |      |
|  char   |     16bit      | 表示Unicode编码 |                                                              |      |
| boolean | 1bit（不知道） |                 |                                                              |      |

### 1.2 变量

| 值得注意的几个地方                                           |
| ------------------------------------------------------------ |
| 1.不能使用未初始化的变量                                     |
| 2.变量的声明尽量靠经第一次使用的地方                         |
| 3.常量要用final关键字，常量名最好大写，一生只能被赋值一次 。static final 用来定义类常量。 |
| 4.const 目前是java的保留字还未使用，常量必须使用final来声明。 |

### 1.3运算符

+、-、*、 / % 分别表示 加、减、乘、除、取余  结果的数据类型为参数的数据类型的范围最大的那个

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

### 1.4 字符串

java无内置字符串，标准类库提供了预定义类String （官方已经定义好的,非原生）。

<font color="red" >**每个用双引号括起来的字符串都是String类实例**</font>

1. **不可变**

   根据String源码发现，String对象没有修改自己数值的方法，只有生成字符串对象的方法（不改变自身对象的值）。

2. **String 常量共享**

   什么是String常量？只要是只要是用双引好包裹表示就相当于生成一个String常量。比如 String a=new String("abc"); 其实是生成了两个字符串常量一个是“abc”字符串常量对象； 另一个是值为“abc”的String对象；虽然它们两个的值相等的，但是他们不是一个对象。

   看下面代码：

   ```java
   		String strA = "112";
           String strB = "112";
           String strC = new String("112");
           String strD = "11" + "2";
           String a="11",b="2";String strE=a+b;
           String strF=a+"2";
           System.out.println("strA==strB:"+(strA==strB));
           System.out.println("strA==strC:"+(strA==strC));
           System.out.println("strA==strD:"+(strA==strD));
           System.out.println("strA==strE:"+(strA==strE));
           System.out.println("strA==strF:"+(strA==strF));
   ```

   打印结果

   ```text
   strA==strB:true
   strA==strC:false
   strA==strD:true
   strA==strE:false
   strA==strF:false
   ```

我们先来搞清楚== 和equals

<font color="red">**值比较？地址比较？**</font>

​			== 就是值比较，不过比较的值是引用类型的值，引用类型的值是什么？就是所指向对象的地址。例如：String a= new String("abc") 就是都这个函数返回一个引用类型的值赋给了 引用类型a; 

​		equals方法是对象的方法，只不过引用类型可以调用，进而可以比较他们指向对象的值。还有一点需要注意equals比较对象之间的值是否相等是根据对象的特性来写的。

strA==strB:true  引用类型指向同一个常量String 。所以他们同一个对象。

strA==strC:false 两个不同的对象 new String()不做共享变量

strA==strD:true 通过反编译可以看到这种写法与strA strB没有任何区别

strA==strE:false String strF=a+"2"; 字符串拼接 只要里面含有一个非常量，他就会生成一个非常量的String



咱们再在探究一下 new String("123"); 先看下面这段代码。

```java
		 char [] a={'a','c','d'}; char[] b=a;
         b[0]='A';System.out.println(a[0]);
```

打印结果

```text
A
```

说明数组也是一个对象，也就是可以用引用类型来指向。

再来看一下String 的new String方法

```java
  	public String(String original) {
        this.value = original.value; // private final char value[]; 
        this.hash = original.hash;  //private int hash; 
    }
```

也就说 this.value 和original.value 引用的是同一个数组对象。 所以说original不管所表示的字符串多大，只要它存在this的生成速度是极快，和大小没有影响。

3. **String注意要点**

 contact方法

```java
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}
```

concat方法的本质是生成一个新的String，从两个字符串中一个一个复制。这种方法不适合使用在连续向超大型字符串上拼接字符串。因为它会一个一个字符的复制到新的字符串上，极度浪费时间。”abc................................“.concat("a")， 这样循环几次就会极度浪费时间。

```java
String a="abc......"//超大字符串
while(有限次){
    a=a.concat("a")
}
```



上面的代码在有限的时间内运行不了几次



a+b的本质什么？ StringBuilder有什么弊端？ 小心StringBuilder的扩容机制导致内存溢出

4. **码点和代码单元**



5.**常用API**

|                        签名                         |                             解释                             |
| :-------------------------------------------------: | :----------------------------------------------------------: |
|               char charAt (int index)               | 返回给定位置的代码单元。除非对底层的代码单元感兴趣，<br />否则不需要调用这个方法。 |
|             int codePointAt(int Index)              |                  返回从给定位置开始的码点。                  |
| int offsetByCodePoints(int startlndex, int cpCount) |   返回从 startlndex 代码点开始位移 cpCount 后的码点索引。    |
|            int  compareTo(String other)             | 按照字典顺序如果字符串位于 other 之前，返回一个负数；如果字符串位于 <br />other 之后，返回一个正数； 如果两个字符串相等，返回 0。 |
|               IntStream codePoints()                | 将这个字符串的码点作为一个流返回。调用 toArray 将它们放在一个数组中。 |
| new String(int[] codePoints, int offset, int count) |    用数组中从 offset 开始的 count 个码点构造一个字符串。     |
|            boolean equals(0bject other)             |             如果字符串与 other 相等，返回 true。             |
|                        ....                         |                            .....                             |
|                  查看核心技术卷一                   |                                                              |

### 1.5 输入输出

1. **读取输入**

输标准出流输出内容到控制台非常简单，System.out.println 即可。

读取标准输入流System.in，得用到Scanner对象与标准输入流相关联，例如：Scanner in = new Scanner(System.in); 然后利用Scanner类的方法进行读取

控制台读取密码不用Scanner 因为可见。用Console类来实现	

```java
//在控制台运行程序，要不Console为空
Console cons = System.console();
String username = cons.readLine("User name: ");
char[] passwd = cons.readPassword("Password:", new Object[0]);
```

输出结果：密码输入不可见

```text
User name: root   
Password:
```





> java.util.Scanner5.0 



| API                                                 | 说明                                           |
| --------------------------------------------------- | ---------------------------------------------- |
| Scanner (InputStream in)                            | 用给定的输人流创建一个 Scanner 对象            |
| String nextLine( )                                  | 读取输入的下一行内容。                         |
| String next( )                                      | 读取输入的下一个单词（以空格作为分隔符)        |
| int nextlnt( )<br />double nextDouble( )            | 读取并转换下一个表示整数或浮点数的字符序列。   |
| boolean hasNext( )                                  | 检测输人中是否还有其他单词 。                  |
| boolean hasNextInt( )<br />boolean hasNextDouble( ) | 检测是否还有表示整数或浮点数的下一个字符序列。 |

> java.Iang.System 1.0

static Console console( ) 

| API                       | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| static Console console( ) | 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个<br /> Console 对象，否则返回 null。 对于任何一个通过控制台窗口启动的<br />程序，都可使用 Console 对象。否则，其可用性将与所使用的系统有关 。 |

> java.io.Console 6

| API                                                          |                             说明                             |
| ------------------------------------------------------------ | :----------------------------------------------------------: |
| static char[] readPassword(String prompt, Object...args)<br />static String readLine(String prompt, Object...args) | 显示字符串 prompt 并且读取用户输入，直到输入行结束。 args 参数可以用来提供输人格式。 |

2.**格式化输出**

System.out.printf 方法可以进行格式化输出

System . out . printf（ ”8.2f“, x);

每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数

![image-20201125140838961](image/image-20201125140838961.png)

![image-20201125140544805](image/image-20201125140544805.png)

具体使用https://blog.csdn.net/jhsword/article/details/108574442



它是怎么解析这些字符串的，是通过Formatter类进行了解析，这个与String.format方法用的一个类进行的解析。我们在写程序的过程中可以适当借用这些预定义类进行功能的实现。

3.**文件的输入输出**

记住几个API

> java.util.Scanner 5.0

| API                  | 说明                                     |
| -------------------- | ---------------------------------------- |
| Scanner(File f)      | 构造一个从给定文件读取数据的 Scanner。   |
| Scanner(String data) | 构造一个从给定字符串读取数据的 Scanner。 |
|                      |                                          |

> java.io.PrintWriter 1.1

| API                              | 说明                                                      |
| -------------------------------- | --------------------------------------------------------- |
| PrintWriter(String fileName)     | 构造一个将数据写入文件的 PrintWriter。 文件名由参数指定。 |
| static Path get(String pathname) | 根据给定的路径名构造一个 Path。                           |

### 1.6 大数值

> Biglnteger 和 BigDecimaL 这两个类可以处理包含任意长度数字序列的数值。

对于c++得自己写大数值的计算，一般做算法题要求会会写简单的大数值的运算+ - * /

BigInteger 存在4000行代码，里面用到许多经典算法，值得后续研究。

### 1.7 数组

1. **支持循环**

   数组是支持来遍历数组的值。实现Iterable的类对象也支语法

   ```java
   for (variable : collection)  statement
   ```

   

2. **数组的初始化以及匿名数组**

   int[] a = new int[100];

   上面这种是创建了一个数组，存在了一个数组对象，被默认初始化。但是数组元素未必含有值。

   数字数组所有元素初始化为0；boolean数组初始化为false，对象数组初始化为了null

```java
Arrays.toString(a); //a为一个数组
```

若a 为基本数据类型的数组，就会以为一个数组元素的值组成字符串

若a为对象数组，就会调用对象的toString方法组成字符串

```java
new int[] { 17, 19, 23, 29, 31, 37 } //初始化匿名数组
```

```java
int [] a={17, 19, 23, 29, 31, 37 };
a=new int[] { 17, 19, 23, 29, 31, 37 }; 
a={17, 19, 23, 29, 31, 37 }; //报错
```

匿名数组的语法形式可以在不重新创建变量的情况下，可以重新初始化一个数组

与字符串一样 数组长度为0和null不相同

3.**数组拷贝**

在前面已经验证，数组也是一种object。也是需要引用类型来指向，所以拷贝数组的话不能使用"="，所以需要Arrays.copyOf()函数来进行深拷贝。

Array.copyof()可传入对象数组进行拷贝，它的原理是什么呢？

```java
@SuppressWarnings("unchecked")
public static <T> T[] copyOf(T[] original, int newLength) {
    return (T[]) copyOf(original, newLength, original.getClass());
}
```

```java
public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    @SuppressWarnings("unchecked")
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
}
```

解释 说明



Arrays一些比较有用的API

> java . util.Arrays 1.2

| API                                                          | 说明 |
| ------------------------------------------------------------ | ---- |
| static String toString(type[]a)                              |      |
| static type copyOf(type[]a, int length)<br />static type copyOfRange(type[]a , int start, int end) |      |
| static void sort(type [ ] a)                                 |      |
| static int binarySearch(type[] a , type v)<br />static int binarySearch(type[]a, int start, int end , type v) |      |
| static void fill(type[]a , type v)                           |      |
| static boolean equals(type[]a, type[]b)                      |      |

4. **多维数组**

同样可以嵌套使用 来访问元素

```java
for (double row : a)
	for (double value : row)
		do something with value
```

a为一个二维数组  则a[i]表示一个一位数组

```java
int[][] odds = new int[NMAX + 1] [] ;
for (int n = 0; n <= NMAX ; n++)
	odds [n] = new int[n + 1] ;
```

表示的不规则数组为

```text
0
0 0
0 0 0
0 0 0 0
0 0 0 0 0
.....
```

## 第二章 对象和类



### 2.1 面向对象设计

1. **类**

面向对象设计即OOP

对象的一个重要概念说就是封装（encapsulation），把对象的数据和行为组装到一个包，并对对象的使用者隐藏数据的实现方式。

实例域：对象中的数据     方法：操作数据的过程

封装的关键：不能让类中的方法直接访问其他类的实例域。

继承 更加便于定义自定义类，方便扩展。

2.**类之间的关系**

![image-20201125212726997](image/image-20201125212726997.png)

### 2.2 预定义类

1. **对象和对象变量**

对象变量不是一个对象，只是可以存储对象的引用，也就是引用一个对象。对象变量可以通过引用调用所引用的对象的方法。

局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。



2. **多使用官方的自定义类**

比如

> java.time.LocalDate 8

| API                                                          | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| static Local Time now( )                                     | 构造一个表示当前日期的对象。                                 |
| static LocalTime of( int year , int month , int day )        | 构造一个表示给定日期的对象。                                 |
| int getYear( )<br />int getMonthValue( )<br />int getDayOfMonth( ) | 得到当前日期的年、月和曰。                                   |
| DayOfWeek getDayOfWeek( )                                    | 得到当前日期是星期几， 作为 DayOfWeek 类的一个实例返回。 调用 getValue 来得到<br/>1 ~ 7 之间的一个数，表示这是星期几，1 表示星期一，7 表示星期日。 |
| Local Date piusDays( int n )<br />LocalDate minusDays(int n) | 生成当前日期之后或之前 n 天的日期。                          |

### 2.3 自定义类

1. **隐式参数和显示参数**

```java
//Employee类的一个方法
public void raiseSalary(double byPercent)  
{
    double raise = salary * byPercent / 100;
    salary += raise;
}

number007.raiseSalary(5);
```

 byPercent为显示参数， number007为隐式参数，在方法中this可以表示隐式参数。（this要与关键字super使用上做好区分）

2.  **final实例域**

final修饰的变量值是不允许改变的。

修饰基本类型的变量时，他表示的值是不会改变的。当它修饰对象变量时，对象变量的引用值是不会改变的，也即是说所引用的对象（如果是可变类对象）自身的值是可以修改的。

什么是不可变类对象----类中只有final修饰的基本类型域或者不可变类型对象。  

### 2.4 静态域与静态方法

### 2.5 方法参数

方法参数是按照值传递，对象参数则传递拷贝的引用值，基本类型参数则直接传递拷贝代表的值

### 2.6 对象构造

**重载（overloading）**：一个类里相同的方法名 不同的签名（参数的个数+参数的类型）。 下面这种调用就是重载

​	     StringBuilder messages = new StringBuilder();

​		 StringBuilder todoList = new StringBuilder("To do:\n")；



**默认域初始化**

​		构造器中没有显示的对域进行初始化会被自动地赋值，数值为0 、布尔值为false、对象引用为null

**无参数构造器**

​		编写类时，如果没有编写构造方法，会自动生成一个隐式 无参数构造方法。和下面操作的效果一样

```java
public Employee(){
}
```

**显示域初始化**

在执行构造方法之前进行赋值

```java
class Employee{
    private String name ="";
}

```

```java
class Employee{
    public Employee(String name){
        this.name=name;
    }
}
```

**初始化块**

```java
class Employee
{
    private static int nextld;
    private int id;
    private String name;
    private double salary;
	// object initialization block
    {
        id = nextld;
        nextld++;
    }
    public Employee(String n, double s){
        salary = s;
        name=n;
    }
}
	
```

初始化的执行顺序

1 ) 所有数据域被初始化为默认值（0、 false 或 null )

2 ) 按照在类声明中出现的次序依次执行所有域初始化语句和初始化块。

3 ) 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体

4 ) 执行这个构造器的主体。

**对象析构与 finalize 方法**

​	当回收对象的时候执行这个方法。当JVM回收一个对会判断对象是否覆盖这个方法，若没有覆盖直接回收。否则会把这个对象放入一个F-Queue队列，线程就会执行队列里面对象的finalize方法。执行后再次进行可达性分析判断是否回收。若不回收在直接复活。 finalize只会被系统调用一次

![img](image/16c6b138ec69932d)

### 2.7 包

**静态导入**

**包作用域**

### 2.8文档注释

### 2.9类设计技巧

| 一定保证的数据的私有                                         |
| ------------------------------------------------------------ |
| 一定要对数据的初始化，虽然java对对象的实例进行初始化（不对局部变量的初始化），最好不要依赖系统的默认初始化，而是要显示的对数据进行初始化 |
| 不要在类中使用过多的基本类型<br />private String street;<br/>private String city;<br/>private String state; <br />可以把上面这个几个变量封装成Address类，这样便于管理。 |
| 不是所有的域需要域访问器和域更改器--最大封装性防止数据被破坏 |
| 将职责过多的类进行分解 (一副扑克牌分解为 一副扑克牌和一张扑克牌) |
| 类名和方法名要能够体现它们的职责                             |
| 优先使用不可变类                                             |

## 第三章  继承



### 3.1 超类和子类

####  定义子类

```java
public class Employee
{
    // instance fields
    private String name ;
    private double salary;
    private LocalDate hireDay;
    // constructor
    public Employee(String n , double s, int year , int month , int day)
    {
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day) ;
    }
    // a method
    public String getName()
    {
        return name;
    }
    public double getSalary()
    {
   	 	return salary;
    }
}
```



```java
public class Manager extends Employee
{
	private double bonus;
    public void setBonus(double bonus)
    {
 	   this.bonus = bonus;
    }
}
```

子类将拥有父类的所有的方法和域，在设计的时候应该将通用的方法放入到父类，将特殊用途的方法放到子类中

#### 覆盖方法

​	父类的方法并不一定适用于子类的使用，所以需要我们在子类里面进行方法重写的也就是覆盖父类实现的方法。覆盖只是对外部调用而言的，子类覆盖了父类的某一方法，子类中依然可以调用这个方法（它依然继承且拥有这个方法这是只能在类内部进行调用），用super.method()调用，因为需要标识否则会调用子类中重写的方法。

> super只有标识的作用,标识出在父类中声明的方法。而this指向的是当前对象

```java
public class Manager extends Employee
{
	private double bonus;
    public void setBonus(double bonus)
    {
 	   this.bonus = bonus;
    }
    
    public double getSalary()
    {
    	//return salary + bonus; // won't work
         return super().getSalary() + bonus; // won't work
    }
}
```

在子类里面是无法访问到salary，因为他是在父类中声明并且是私有的，子类中是不能访问。也可以这么理解子类拥有这个域，但是不能直接访问。

#### 子类构造器

由于 Manager 类的构造器不能访问 Employee 类的私有域，所以必须利用 Employee 类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用

```java
//显示调用的方法
public Manager(String name, double salary, int year, int month, int day)
{
    super(name, salary, year, month, day) ;
    bonus = 0;
}
```

​		非静态类，都会有构造器。子类构造器一定会调用父类的构造器，如果不显示调用父类构造器就会隐式调用父类的默认构造器（无参数的构造器），如果父类没有默认的构造器就会报错。

![image-20201210214756365](image/image-20201210214756365.png)

![image-20201210214245690](image/image-20201210214245690.png)





|  |  |
| ----- | ------------------------------------------ |
| this |        1.引用隐式参数<br />2.调用该类的其他构造器                                    |
| super | 1.调用超类的方法<br />2.调用超类的构造器 |

####  多态

​	对象变量是多态，父类对象变量可以引用子类对象实例。 一个 Employee 变量既可以引用一个Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象（例如：Manager）。但是不能将一个超类的引用赋给子类变量。这样会导致错误。 

#### 理解方法的调用

从编译器和虚拟机的角度解释调用x.f(args)的过程（x可能是一个声明的变量，也可能是this,或者隐式的this）

① **找出所有的候选方法：**编译器根据x的声明的类型，假设为C类型，找出C类型所有名字f的方法和父类名字为f的方法并且是public的访问权限。

② 编译器根据传入的参数的对象的类型找到适合的方法，这个过程包括参数的类型自动转化。（现在我们已经确定调用的方法的方法名和签名）-------这里只是确定将要调用的方法样式，并不是一定调用当前这个。

③如果找到的这个方法是private static finnal 那么编译器肯定会调用的是上面的找到的那个方法。

不知道大家发没发现上面是在编译期间的工作室，如果在第三步编译器就能找到确切的执行哪个方法就不用在运行的时候确定了。 所以叫**静态绑定**



④ 如果不是上面的方法修饰符，那就不一定是我们找到的那个方法。所以虚拟机只能在运行的时候去确定到底执行哪个方法。虚拟机会预先为每个类创建方法表。虚拟机直接查这个表就行。假设x指向的是D类对象（C类的子类），直接搜寻这个D类的方法表（方法表里面的方法不一定都是在D类中声明的方法也可能是在的C类中声明）

下面是Employee和Manager的方法表

![image-20201211224627955](image/image-20201211224627955.png)

![image-20201211224547732](image/image-20201211224547732.png)



第四步是动态绑定无需现有代码进行修改就可对代码进行扩展，比如新增增一个C的子类 E    C类引用就可以指向E并且可以调用E类中的某些方法



#### final

|             |                                                              |
| ----------- | ------------------------------------------------------------ |
| final修饰类 | 这个类不能被继承                                             |
|    final方法       | 这个方法不能被子类重写                                       |
|   final修饰引用变量    | 修饰引用表示这个 引用值不能改变，也就是一直引用这个对象不能改变 |
|    final修饰基本类型     | 修饰基本类型表示这个这个变量表示值不能被改变                 |

​	final类型的数据若在定义时没有显示初始化，是没有默认初值的。 对于在定义时没有显式初始化的，应该在构造方法中进行初始化.并且final修饰的数据一生只能初始化一次

#### 强制类转换

#### 抽象类

#### 受保护的访问

### 3.2 Object所有类的超类

​		所有的类更具继承关系往上追踪都是Object对象，在java里面它是所有类的始祖。如果没有指出某个类的父类，那么这个类就继承于Object类。所以object类的变量可以引用任何类型的对象。

> **Object类是所有类的始祖，任何类都拥有Object中定义的方法**

我们现在简单看一下Object类里面定义了哪些方法

#### equals方法

> equals(Object obj)

这里值判断了两个对象引用是否具有相同的引用(this引用变量与传入的值的值比较。

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

每个对象都有一个隐式参数，一个指向自己的变量 this)因为每一个类的相等含义不相同，所以一般都会重写这个方法。但是重写的时候也不是随便的重写的，要不会造成不必要的麻烦遵循以下原则

| 准则   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 自反性 | x.equals(x) 必须返回true                                     |
| 一致性 | x.equals(y)  x与y所指向的对象只要不被改变，并且x y 指向不改变。x.equals(y)无论被调用多少次它结果也不会被改变 |
| 传递性 | x.equals(y) 与y.equals(z)结果一致。那么 x.equals(z)的结果与他们一样 |
| 对称性 | x.equals(y) 与y.equals(x)结果一致                            |
| 其他   | x.equals（null）永远返回false；<br/>For any non-null reference value  ` x`,    `x.equals(null)`  should return  `false`. |

还有一点需要注意那就是

> 重写了equals方法必须重写hashcode方法，因为两个相等的对象hash codes
>
> ```java
> /**
> *Note that it is generally necessary to override the {@code hashCode}
> * method whenever this method is overridden, so as to maintain the
> * general contract for the {@code hashCode} method, which states
> * that equal objects must have equal hash codes.*/
> ```



#### hashcode方法

>  public native int hashCode();

```java
public native int hashCode();
```

​	顺便说一下带有native关键字的方法。这样的函数为原生函数，这个方法相当于是接口调用有其他语言实现的方法。比如c语言实现的方法。这些语言编写的方法会被编写成动态链接库文件（dll），由我们的直接去调用使用。

```java
/*As much as is reasonably practical, the hashCode method defined by
* class {@code Object} does return distinct integers for distinct
* objects. (This is typically implemented by converting the internal
* address of the object into an integer, but this implementation
* technique is not required by the
* Java&trade; programming language. */
```

 这个hashCode()方法默认是由对象的地址转换而来的

有些情况需要与系统底层进行一些交互，由于java是跨平台牺牲了一些对底层的控制。所以需要借助其他语言一些协助。详情内容参考 <a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">这里</a>



hashCode()有以下通用约定，也就是我们重写这个方法需要注意的地方。为什么需要注意呢？因为有许多的地方调用了hashcode这个方法比如HashMap这个类的对象在存储的时候就利用到了要存储的对象的hashcode方法。不能影响规则。

```java
/**
* <p>
* The general contract of {@code hashCode} is:
* <ul>
* <li>Whenever it is invoked on the same object more than once during
*     an execution of a Java application, the {@code hashCode} method
*     must consistently return the same integer, provided no information
*     used in {@code equals} comparisons on the object is modified.
*     This integer need not remain consistent from one execution of an
*     application to another execution of the same application.
* <li>If two objects are equal according to the {@code equals(Object)}
*     method, then calling the {@code hashCode} method on each of
*     the two objects must produce the same integer result.
* <li>It is <em>not</em> required that if two objects are unequal
*     according to the {@link java.lang.Object#equals(java.lang.Object)}
*     method, then calling the {@code hashCode} method on each of the
*     two objects must produce distinct integer results.  However, the
*     programmer should be aware that producing distinct integer results
*     for unequal objects may improve the performance of hash tables.
* </ul>
* <p> 
*/
```

| 通用约定                                                     |
| ------------------------------------------------------------ |
| 只要equal方法中用到的信息没有被修改，不管调用多少次此方法返回的数值是不变的 |
| 两个对象通过equals返回true，两个对象的执行此方法返回的数值是一样的即hashcode一样 |
| 不相等的对象不要求一定得产生不同的数值，但是不同对象的hash值会提高hash的性能（可能减少了hash冲突） |

#### toString方法

这个方法的作用就是返回对象的一些信息。来能标识出这个对象。

```java
 /**Returns a string representation of the object. */
```

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

根据我们的自己定义的类相应的重写这个方法再打印一些信息的时候能使我们更加认识对象的内容，尤其是在调试过程中能把关键的信息提取出来

#### clone方法

```java
//Creates and returns a copy of this object.
protected native Object clone() throws CloneNotSupportedException;
```

创建并返回一个一样对象。





| 通用约定                                                     |
| ------------------------------------------------------------ |
| x.clone() != x return                            return true |
| x.clone().getClass() == x.getClass()   return true           |
| x.clone().equals(x)                               return true |
| clone()返回的对象是靠super.clone()获得的,Object的对象除外    |
| 复制的对象要保持独立性                                       |
|                                                              |
|                                                              |
|                                                              |

怎么样复制的对象要保持独立性？

1.复制内部组成的对象，并把[**(class)super.clone]**的对象引用这些复制出的内部对象

2.如果一个对象只包含父类的字段或者是不可变对象，那么这个类的clone()方法不许修改 super.clone()返回的对象

#### wait方法

```java
public final native void wait(long timeout) throws InterruptedException;
```

```java
public final void wait() throws InterruptedException {
    wait(0);
}
```



#### notify方法



#### notifyAll方法



#### finalize方法

```java
protected void finalize() throws Throwable { }
```



















| 方法名                 | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Class getClass( )      | 返回包含对象信息的类对象。稍后会看到 Java 提供了类运行时的描述<br/>，它的内容被封装在 Class 类中。 |
| String getName( )      | 返回这个类的名字。                                           |
| Class getSuperclass( ) | 以 Class 对象的形式返回这个类的超类信息。                    |



### 3.3 泛型数组

JAVA虽然运行的时候可以确定数组的大小,但是无法在程序运行的时候动态更改数组的大小。

``` java
int actualSize = . . . ;
Employee[] staff = new Employee[actualSize];
```

在java中我们可以利用ArrayList添加或者删除元素，具有自动调节数组大小的作用。ArrayList 是一个采用类型参数（ type parameter ) 的泛型类（ generic class)。 

为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如ArrayList<Employee> 。在第后面章节将可以看到如何自定义一个泛型类。

```java
ArrayList<Employee> staff = new ArrayList<Eniployee>();
ArrayList<Employee> staff = new ArrayList<>()； //1.7之后可以简略写。
```

#### ArrayList动态改变存储空间

ArrayList内部管理着一个数组，再利用add方法把数组空间用完的时候，数组列表就会自动创建一个更大的数组并将所有元素从较小的数组的中拷贝到大的数组中。

#### 定义数组的容量的大小

可以在声明的时候声明的数组的大小`ArrayList< Employee> staff = new ArrayList<>(100) ;`也可以在填充数据之前调用`staff.ensureCapacity(100);`

#### 方法总结

| 方法名                              | 作用                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| ArrayList< E >()                    | 构造一个空数组列表。                                         |
| ArrayList<E>( int  initialCapacity) | 用指定容量构造一个空数组列表。                               |
| boolean add(E obj )                 | 在数组列表的尾端添加一个元素。 永远返回 true。               |
| int size()                          | 返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。) |
| void ensureCapacity( int capacity)  | 确保数组列表在<font color="red">**不重新分配存储空间**</font>的情况下就能够保存给定数量的元素。 |
| void trimToSize()                   | 将数组列表的存储容量削减到当前尺寸。                         |
| void set(int index，E obj)          | 设置数组列表指定位置的元素值， 这个操作将覆盖这个位置的原有内容。 |
| E get(int index)                    | 获得指定位置的元素值。                                       |
| void add(int index,E obj)           | 向后移动元素，以便插入元素。                                 |
| E removed (int index)               | 删除一个元素,并将后面的元素向前移动。被删除的元素由返回值返回。 |



### 3.4 对象包装器和自动装箱

所有的基本类型都有一个与之对应的类相对应

| 基本类型 | 类        |
| -------- | --------- |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| short    | Short     |
| Byte     | byte      |
| char     | Character |
| void     | Void      |

泛型相关的类不可以用基本类型的，就如ArrayList<int>是不允许存在，但是我们可以利用它的包装类来进行存储。ArrayList<Integer> list = new ArrayList<>()；

list. add(3);编译器把这条语句自动装箱成list.add(Integer.value0f(3)); 我们可以用反编译查看出来。

int n = list . get(i);将会被编译器自动拆箱成 int n = list.get(i).intValue();

自动装向的时候调用了 `valueOf`方法，这个方法利用了一个缓存存储一些Integer对象

```java
/* This method will always cache values in the range -128 to 127,
 * inclusive, and may cache other values outside of this range.*/
//range [-128, 127] must be interned (JLS7 5.1.7)
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

所以 Integer a = 100; Integer b = 100;  a b两个引用引用的是一个对象

```java
//以 int 的形式返回 Integer 对象的值（在 Number 类中覆盖了 intValue 方法）。
int intValue( )
    
//以一个新 String 对象的形式返回给定数值 i 的十进制表示。  
static String toString(int i )

//返回数值 i 的基于给定 radix 参数进制的表示。
static String toString(int i ,int radix)
    
//返回字符串 s 表示的整型数值，
//给定字符串表示的是十进制的整数（第一种方法)，
//或者是 radix 参数进制的整数（第二种方法 )。
 static int parselnt(String s)
 static int parseInt(String s,int radix)
 
 //java.text.NumberFormat 1.1 返回数字值，假设给定的 String 表示了一个数值。
 Number parse(String s)
```



### 3.5 参数数量可变方法

在 `PrintStream`类里面有一个这样的方法，我们可以有以下方式的调用

`System.out.printf（"%d", n); `
`  System. out .printf("%d %s”,n, "widgets");` 

编译器视角

System.out . printf("%d %s”, new Object[] { new Integer(n), "widgets" } );

方法内容见下面，里面两个参数一个 格式化字符串 一个是Object数组

```java
public PrintStream printf(String format, Object ... args) {
    return format(format, args);
}
```

Object… 参数类型与 Object[ ]完全一样。并且允许将一个数组传递给可变参数方法的最后一个参数。



### 3.6 枚举类

#### 用法

我们来看下面枚举的例子

```java
public enuni Size { SMALL , MEDIUM, LARGE, EXTRAJARGE };
```

上面声明定义的就是一个类 而且他有四个实例（就是上面写出来的那四个），因此在比较两个枚举值时直接用“==”就可以了

我们来看一个更加全面的例子

```java
public enum Size
{
    SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
    private String abbreviation;
    private Size(String abbreviation) { this , abbreviation = abbreviation; }
    public String getAbbreviation() { return abbreviation; }
}
```

上面的例子说明枚举类型可以有方法、域和构造器。构造器在构造枚举常量才会被调用，枚举常量就是上面那四个对象。

#### Enum 类

所有的枚举类型都继承与Enum类，是它的子类

```java
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable
```



下面是它所拥有的方法，所有的枚举类都会继承它的这些方法。

![image-20201219185740882](image/image-20201219185740882.png)

| 方法名                                              | 作用                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| static Enum valueOf(Class enumClass , String name ) | 返回指定名字、给定类的枚举常量。                             |
| String toString( )                                  | 返回枚举常量名                                               |
| int ordinal ()                                      | 返回枚举常量在 enum 声明中的位置，位置从 0 开始计数。        |
| int compareTo( E other )                            | 如果枚举常量出现在 Other 之前，则返回一个负值；如果 this=other，则返回 0; 否则，返回正值。枚举常量的出现次序在 enum 声明中给出。 |





### 3.7 反射

**反射库（ reflection library)** 提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java 代码的程序。

> 能够分析类能力的程序称为反射（ reflective)

先说说它的作用把

+ 在运行时分析类的能力
+ 在运行时查看对象，例如编写一个toString方法供所有类使用
+ 实现通用的数组的操作代码
+ 利用Method对象。

如果你想构造工具这一节的内容非常有用，几乎所有的java工具、框架都是用到了反射实现的

#### 3.7.1 Class类

##### 三种获得Class对象的方法

​	Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。这个信息（对象）所属的类是Class。每个对象的都有自己的Class类，属于同一个类的对象都会被同一个Class对象维护信息。Object 类中的 **getClass( )** 方法将会返回一个 Class 类型的实例。

```java
Employee e;
Class cl = e.getClass();
```

最常用的 Class 方法是 getName。 这个方法将返回类的名字。

利用Class静态方法来获得对应的Class对象

```java
String className = "java.util.Random";
Class cl = Class.forName(className) ;
```

className 只能是类名或者是接口名才能使用这个方法，否则会抛出异常checkedException(受检异常)

> **Class.forName的好处**。

当main方法被执行的时候，他会加载它所需要的类，这些类也就去加载他们所需要的类，对于一个大型程序来说可能需要很长的时间才能启动起来。我们可以利用Class.forName去手动的加载那些类，不显示的使用一些类，当我们需要的时候采取手动加载这些类。（一般需要多态去配合）

第三种获得Class对象的方法 **T.class** T是任意的java类型（不光是java类）或者void关键字。

```java
Class cl1 = Random.class;
Class cl2 = int.class;   //任意的java类型包括基本类型
Class cl3 = Double[].cl ass;
```

##### newlnstance 方法

返回描述类名为 className 的 Class 对象。将 forName 与 newlnstance 配合起来使用，可以根据存储在字符串中的类名创建一个对象

```java
String s = "java.util.Random";
Object m = Class.forName(s).newlnstance();
```

如果需要调用特定的带参数构造器去创建对象就需要 Constructor 类中的 newlnstance 方法。

> java.Iang.reflect.Constructor 1.1

Object newlnstance(Object[] args)
构造一个这个构造器所属类的新实例。
参数：args 这是提供给构造器的参数。有关如何提供参数的详细情况请参看 5.7.6
节的论述。

> java.Iang.Throwable 1.0

void printStackTrace()
将 Throwable 对象和栈的轨迹输出到标准错误流。

#### 3.7.2 利用反射分析类的能力

>  java. lang.Class 1.0

| 方法名                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Field[] getFields()                                                                                                                      <br />Filed[] getDeclaredFields() | getFields 方法将返回一个包含 Field 对象的数组，这些对象记录了这个类或其超类的**公有域**。getDeclaredField 方法也将返回包含 Field 对象的数组，这些对象记录了这个类的**全部域**。 如果类中没有域，或者 Class 对象描述的是基本类型或数组类型，这些方法将返回一个长度为 0 的数组。 |
| Method[]  getMethods()                                                                                  Method[] getDeclareMethods() | 返回包含 Method 对象的数组：getMethods 将返回所有的公有方法，<br/>包括从超类继承来的公有方法；getDeclaredMethods 返回这个类或接口的全部方法，但不包括由超类继承了的方法。 |
| Constructor[] getConstructors()  Constructor [] getDeclaredConstructors() | 返回包含 Constructor 对象的数组，其中包含了 Class 对象所描述的类的所有公有构造器（getConstructors ) 或所有构造器（getDeclaredConstructors)。 |



>  java.lang.reflect    -Field - Method - Constructor 

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Class getDeclaringClass( )                                   | 返冋一个用于描述类中定义的构造器、方法或域的 Class 对象      |
| Class[] getExceptionTypes ( ) ( 在 Constructor 和 Method 类 中） | 返回一个用于描述方法抛出的异常类型的 Class 对象数组。        |
| int getModifiers( )                                          | 返回一个用于描述构造器、方法或域的修饰符的整型数值。使用 Modifier 类中的这个方法可以分析这个返回值。 |
| String getName( )                                            | 返冋一个用于描述构造器、方法或域名的字符串。                 |
| Class[] getParameterTypes( ) ( 在 Constructor 和 Method 类 中） | 返回一个用于描述参数类型的 Class 对象数组。                  |
| Class getReturnType( ) ( 在 Method 类 中）                   | 返回一个用于描述返H类型的 Class 对象。                       |

> java.lang.reflect.Modifier 1.1



![image-20201219202826677](image/image-20201219202826677.png)

#### 3.7.3 在运行时利用反射进行分析



#### 3.7.4 使用泛型编写泛型数组



#### 3.7.5 调用任意方法

| 设计技巧                                                     |
| ------------------------------------------------------------ |
| 将公共操作和域放在超类                                       |
| 不要使用受保护的域                                           |
| 使用继承实现“ is - a” 关系  （要在逻辑上通）                 |
| 除非所有继承的方法都有意义，否则不要使用继承                 |
| 在覆盖方法时，不要改变预期的行为                             |
| 使用多态，而非类型信息                                       |
| 不要过多地使用反射（在编写应用程序的时候，尽量减少使用因为很难发现错误） |





### 3.8 继承的设计技巧

## 第四章 接口、lambda表达式和内部类

### 4.1接口

> 接口不是类，而是对类的一组需求描述

实现接口的类，必须按照接口的规定来实现方法。

举一个具体操作的例子吧

​	Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提： 对象所属的类必须实现了 Comparable 接口。

```java
public interface Comparable<T> 
{
     /**
     * Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.*/								 public int compareTo(T o);
    
}
```

```java
/**
 * Sorts the specified array of objects into ascending order, according
 * to the {@linkplain Comparable natural ordering} of its elements.
 * All elements in the array must implement the {@link Comparable}
 * interface.
 * @param a the array to be sorted
 * @throws ClassCastException if the array contains elements that are not
 *         <i>mutually comparable</i> (for example, strings and integers)
 * @throws IllegalArgumentException (optional) if the natural
 *         ordering of the array elements is found to violate the
 *         {@link Comparable} contract */
  public static void sort(Object[] a) {
     if (LegacyMergeSort.userRequested)
         legacyMergeSort(a);
      else
         ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
   }
 
```

a的类型必须是实现Comparable 接口，才能利用此方法进行排序。

还有一点需要注意的是：实现public int compareTo(T o); 利用加减乘除等运算符返回值的时候，注意四舍五入、数值溢出导致出现含义的偏差

**接口特性**

+ 不能利用new运算符实例化一个接口

+ 声明接口变量

+ 可以instanceof检查某个对象是否实现了某个接口

+ 接口也可以在某些接口的基础上进行扩展

+ 接口中不能包含实例域或静态方法，但却可以包含常量。

  + 接口中的域将被自动设为 public static final

  ```java
  public interface Powered extends Moveable
  {
      double milesPerCallon();
      double SPEED_LIHIT = 95; // a public static final constant
      
  }
  
  ```

+ 接口中的方法都自动地被设置为 public  （和上面的一条差不多）

**接口和抽象类**

有了抽象类为什么还要有接口，每个类只能扩展一个抽象类而接口就不同他就可以扩展很多也不受限制。

java为什么没有多重继承呢？其主要原因是多继承会让语言本身变得非常复杂（如同 C++)，效率也会降低 （如同 Eiffel)。

**静态方法**

java8 允许在接口增加静态方法。

通常把静态方法放到伴随类中，在标准库里面 。比如：Collection/Collections 或 Path/Paths。 

**默认方法（作用）**

可以为接口增加一个默认方法 **default** 关键字进行修饰，以前可不允许写方法，java8后可以写静态方法和defalut修饰的方法。

```java
public interface Comparable<T>
{
	default int compareTo(T other) { return 0; }
	// B y default, all elements are the same
}
```

在以上场景写的那个compareTo方法是没什么用，因为就会被覆盖，上面只是演示怎么使用。来我们看一下以下场景。



```java
public interface MouseListener
{
    void mousedieked(MouseEvent event);
    void mousePressed(MouseEvent event);
    void mouseReleased(MouseEvent event);
    void mouseEntered(MouseEvent event);
    void mouseExited(MouseEvent event);
}
```

 ```java
public interface MouseListener
{
    default void mousedieked(MouseEvent event) {}
    default void mousePressed(MouseEvent event) {}
    default void mouseReleased(MouseEvent event) {}
    default void mouseEntered(MouseEvent event) {}
    default void mouseExited(MouseEvent event) {}
}
 ```

大多数情况下有些类只需要实现MouseListener接口里面一两个方法即可。如果用了default关键字就可以不用把每个放方法进行覆盖。这样一来程序员只关心那一两个方法怎么实现。



假设为Collection定义一个这样的便利方法，这样实现Collection的程序员就不必操心实现isEmpty方法了

```java
public interface Collection
{
    int size(); // An abstract method
    default boolean isEmptyO
    {
    	return size() = 0;
    }
}
```



如果你喜欢翻看源码你就会发现经常有这样的组合，一个接口和一个抽象的伴随类。这个伴随类实现相应的部分或者所有的方法。Collection/AbstractCollection 或 MouseListener/MouseAdapter   java8后，现在我们直接可以把通用方法的实现都合并到接口中。

上面都是在设计的时候增加了方便，现在我们说一下默认方法在维护中的好处

public class Bag implements Collection  我们定义一个类实现了Collection  ，假设Collection  在新的JDK中增加了一个方法，那么我们这个Bag原有的代码 在新的JDK就不会同编译。增加默认就不一样了，不必去实现。

**解决默认方法冲突**

|                                                              |
| ------------------------------------------------------------ |
| 1 ) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。（类优先） |
| 2）接口冲突。 如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型 （不论是否是默认参数） 相同的方法，必须覆盖这个方法来解决冲突。 |

> 千万不要让一个默认方法重新定义 Object 类中的某个方法,这样的重新定义毫无意义，因为是类优先规则

### 4.2 接口示例

**接口与回调**

回调（ callback) 是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。 

*参考观察者模式*

**Comparator 接口**（比较器）

与Comparable接口做好区分

**对象克隆**

![image-20201219233823244](image/image-20201219233823244.png)

浅拷贝会引发安全问题 name是String类型，不可变类。是安全的。但是hireDay是可变的。假设copy里面的变了，original里面的必然会变。因为这个实例域本身引用的是一个。

> 如果类的数据域是基本类型或者不可变类，那么这个浅拷贝就是安全的。如果引用到了可变类那么就小心了。



>  Object 类中 clone 方法声明为 protected , 子类必须重写修饰符改为public才能使用

这说明设计者限制了这一方法的使用，除非你真的可以自己实现。重写这个方法的类还得必须实现clone接口（并没有任何方法，只是一个标志接口），若不实现调用clone方法就会抛出一个受检异常（CloneNotSupportedException）。

 所有数组类型都有一个 public 的 clone 方法，而不是 protected : 可以用这个方法建立一个新数组
，包含原数组所有元素的副本。例如:

```java
int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 };
int[] cloned = luckyNumbers . doneO;
cloned[5] = 12; // doesn' t change luckyNumbers[5]
```

非基本类型呢？？？？？？？？？？？？？



### 4.3 lambda表达式

**最令人激动的变化** 

> lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。

**为什么引入 lambda 表达式**

```java
class Worker implements ActionListener
{
    public void actionPerformed(ActionEvent event)
    {
    // do some work
    }
}
```

像反复执行上面的代码，就把work对象提交到Timer 对象中，然后反复调用

```java
class LengthComparator implements Comparator<String>
{
    public int compare(String first, String second)
    {
   	 return first .length() - second.length();
    }
}
```

想利用上面的比较器（比较规则）传入到比较方法中，对String对象进行排序。

上面两个例子，都有一个共同的特点，把一段代码传入到了某个方法中，这段代码将会在未来某个时间段进行执行。是否向其他语言一样直接传入一段代码（函数式编程）而不是去实例化一个对象再去传入。

**lambda表达式的语法**

```java
(String first, String second)-> first.length() - second.length()
```

上面就是一个λ表达式，把上面**LengthComparator**的写的λ表达式。 单个表达式编译器可以知道怎么返回值，多语句就必须显示的返回值(return)。

```java
(String first, String second) ->
{
    {
        if (first . length() < second .length()) return -1;
        else if (first.length() > second.length()) return 1;
        else return 0;
    }	
}
```



无参数方法同样也必须标明出括号

```java
() -> { for (int i= 100;i>= 0;i-- ) System.out.println(i); }
```



如果我们可以推到出参数类型，就可以省略其写出参数类型

```java
Comparator<String> comp
    = (first, second) // Same as (String first, String second)
    -> first.length() - second.length();

```

如果方法只有一个参数，而且可以推导出，就可以省略出小括号

```java
ActionListener listener = event ->
System.out.println("The time is " + new Date()");
```



**函数式接口**

*对于只有一个抽象方法的接口（可以有default方法，静态方法），需要这种接口的对象时，就可以提供一个 lambda 表达式。这 种 接 口 称 为 函 数 式 接 口 （ functional interface )。*

上面的实现ActionListener和Comparator接口就属于这种函数式接口。



根据上卖弄的说明我们来写出一个例子。

```java
Arrays.sort (words,
(first, second) -> first.length() - second.length()) ;
```



介绍一个很有用的接口

```java
// Represents a predicate (boolean-valued function) of one argument.
@FunctionalInterface
public interface Predicate<T> {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
```

检测一个参数，至于怎么检测就是需要自己实现了。



ArrayList 类有一个 removelf 方法，来移除符合规则的元素

```java
/**
 * Removes all of the elements of this collection that satisfy the given
 * predicate.  Errors or runtime exceptions thrown during iteration or by
 * the predicate are relayed to the caller.*/
@Override
public boolean removeIf(Predicate<? super E> filter) 
```



javaAPI同样提供了许多非常通用的函数式接口，比如`BiFunction`   

描述了参数类型为 T 和 U 而且返回类型为 R 的函数

```java
@FunctionalInterface
public interface BiFunction<T, U, R> {

    /**
     * Applies this function to the given arguments.
     *
     * @param t the first function argument
     * @param u the second function argument
     * @return the function result
     */
    R apply(T t, U u);
    .....
}
```

**方法引用**

就是一种lambda表的式的简略写法。

```java
Timer t = new Timer(1000, event - > System.out.println(event));
```

```java
Timer t = new Timer(1000, Systei.out::println);
```

上面两种写法是等价的。表达式 System.out::println 是一个方法引用（ method reference), 它等价于 lambda 表达式x 一> System.out.println(x)





```java
Arrays.sort(strings，String::conpareToIgnoreCase)
```

上面的String::compareToIgnoreCase 等同于 (x, y) - > x.compareToIgnoreCase(y) ;

方法引用支持三种情况，

+ object::instanceMethod

+ Class::staticMethod

+ Class::instanceMethod

  同样也支持super::instanceMethod ；this::instanceMethod 

  



**构造器应用**





<font color="red">**变量作用域**</font>



```java
public static void repeatMessage(String text , int delay)
{
    ActionListener listener = event ->
    {
        System.out.println(text):
        Toolkit.getDefaultToolkit().beep();
    };
    new Timer(delay, listener).start();
}
```



lambda表达式有三个部分 1.代码块 2.参数 3.自由的变量值，这里指非参数而且不是在代码中定义的变量。

上面的text参数就是自由的变量的值，当repeatMessage方法执行完后，text变量值不存在了lambda表达式代码块中可能还未执行。这种情况下lambda表达式里面的text怎么使用？

其实lambda 表达式捕获了text变量，也就是，lambda 表达式可以捕获外围作用域中变量的值。但是是有限制的，在 lambda 表达式中，只能引用值不会改变的变量（对于基本类型变量就是数值，对于引用变量就是引用值不能改变，指向的对象不能改变。），当然引用的对象本身可以发生改变的。

```java
public static void countDown(int start, int delay)
{
    ActionListener listener = event ->
    {
        start-- ; // Error: Can't mutate captured variable
        System.out .println(start);
    }；
    new Timer(delay, listener),start();
}
```

```java
public static void repeat(String text, int count)
{
    for (int i = 1; i <= count; i++)
    {
         ActionListener listener = event - >
        {
          System.out.println(i + ": " + text);
          // Error: Cannot refer to changing i
        }；
        new Timer(1000, listener).start();
    }
}
```

*上面两种情况都是不被允许的。*



```java
public class ApplicationO
{
    public void init()
    {
    	ActionListener listener= event - >
        {
            System.out.println(this.toString());
        }
    }
}
```



在lambda代码块里面可以引用当前对象变量this，没有什么特殊之处，this的含义和在代码块之外的方法里面使用一样。

还有一点是*lambda 表达式的体与嵌套块有相同的作用域。*

![image-20201220150450307](image/image-20201220150450307.png)



**处理Lambda表达式**

> *使用lambda表达式的重点是延迟执行（deferred excecution）*

下面几种情况

+ 在一个单独的线程中运行代码
+ 多次运行代码
+ 在算法适当的位置运行代码（例如：排序中的比较动作）
+ 发生某种情况时执行代码（例如：点击一个按钮）
+ 只在必要时才运行代码





```java
public static void repeat(int n, Runnable action)
{
	for (int i= 0; i< n; i++) action. run();
}

repeat(10, () - > System.out.println("Hello, World!"));
```

多次运行的代码例子，利用runable接口的例子。

![image-20201220141522853](image/image-20201220141522853.png)

我们现在想增强一下上面的repeat方法，每次都能打印出还剩几次迭代。很明显runable接口并不适合了。现在我们来使用Consumer<T> 接口来实现。

```java
public static void repeat(int n, IntConsumer action)
{
	for (int i= 0; i< n; i++) action.accept(i);
}
repeat(10, i-> System.out.println("Countdown: " + (9 - i));
```

![image-20201220142149979](image/image-20201220142149979.png)

也可以自己定义一个函数接口，最好使用 @FunctionalInterface 关键字，当然也不强求.@FunctionalInterface的作用是 如果你无意中增加了另一个抽象方法， 编译器会产生一个错误消息。 另外 javadoc 页里会指出你的接口是一个函数式接口。

**再谈 Comparator**

Comparator有很多的静态方法需要我们去了解

​	静态 comparing 方法取一个“ 键提取器” 函数。它将类型 T 映射为一个可比较的类型( 如 String )。 对要比较的对象应用这个函数，然后对返回的键完成比较。

```java 
Arrays.sort(people, Comparator.comparing(Person::getName));
```



返回一个比较器，这个比较器是用对象的key（实现comparable接口）来做比较的

```java
 /**
     * Accepts a function that extracts a {@link java.lang.Comparable
     * Comparable} sort key from a type {@code T}, and returns a {@code
     * Comparator<T>} that compares by that sort key.
 */
public static <T, U extends Comparable<? super U>> Comparator<T> comparing(
        Function<? super T, ? extends U> keyExtractor)
{
    Objects.requireNonNull(keyExtractor);
    return (Comparator<T> & Serializable)
        (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    //这里的c1和c2是T类型的, keyExtractor.apply(c1)返回的是类型必须实现Comparable接口
    //在上面的例子中可以发现 T就是Person类 U就是String
}
```
```java
@FunctionalInterface
public interface Function<T, R> {

    /**
     * Applies this function to the given argument.
     *
     * @param t the function argument
     * @return the function result
     */
    R apply(T t);
 }

```
比较绕，好好体会。但是我们一般知道这个方法有什么作用就好。

 *thenComparing 方法*

```java
Arrays.sort(people,Comparator.comparing(Person::getlastName)
.thenComparing(Person::getFirstName));；

```

```java
default Comparator<T> thenComparing(Comparator<? super T> other) {
    Objects.requireNonNull(other);
    return (Comparator<T> & Serializable) (c1, c2) -> {
        int res = compare(c1, c2);
        return (res != 0) ? res : other.compare(c1, c2);
    };
}
```

另外， comparing 和 thenComparing 方法都有变体形式，可以避免 int、 long 或 double 值的装箱。

### 4.4 内部类（静态内部类 普通内部类 匿名内部类）



> **内部类（ inner class) 是定义在另一个类中的类。**

存在的原因如下：

+ 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。
+ 内部类可以对同一个包中的其他类隐藏起来。
+ 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷。（lambda表达式存在之前）



**使用内部类访问对象状态**

```java

public class TalkingClock
{
    private int interval:
    private boolean beep;
    public TalkingClock(int interval, boolean beep) { . . . }
    public void start()
    {
       ActionListener listener = new TimePrinterO
		Timer t = new Timer(interval, listener);
		t.start(); 
    }
    public class TimePrinter implements ActionListener
    // an inner class
    {
        System.out.println("At the tone, the time is " + new Date() )；
		if (beep)Toolkit.getDefaultToolkit.beep()；		
    }
}
```

上面思考一个问题，`TimePrinter`没有相应beep实例域，它是访问的TalkingClock的实例域？？？？？

如果他访问的是TalkingClock的实例域，那么在TimePrinter实例化之前就必须要有一个TalkingClock实例？



注意，这里的 TimePrinter 类位于 TalkingClock 类内部。**这并不意味着每个 TalkingClock都有一个 TimePrinter 实例域** ， 如前面所示，TimePrinter 对象是由 TalkingClock 类的**方法**（非静态方法）构造。也就说这个内部类的实例必须依靠一个外部类的实例来实例化的。

```java
public void actionPerformed(ActionEvent event)
{
    System.out.println("At the tone , the time is " + new Date());
    if (outer.beep)Toolkit.getDefaultToolkit().beep();
}
```









那么他是怎么访问的外部类的？我们这里可以思考一下它是怎么实现的。

![image-20201220205458528](image/image-20201220205458528.png)



外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。

```java
public TimePrinter(TalkingGock clock) // automatically generated code
{
	outer = clock;
}
```

外围类的方法创建内部类实例的时候也把this（当前实例）传入进去。也就是当在 start 方法中创建了 TimePrinter 对象后，编译器就会将 this 引用传递给当前的语音时钟的构造器：

```java
ActionListener listener = new TimePrinter(this); // parameter automatically added
```



不光能利用外部类的方法构造内部类的实例，也可以用下面的方法也可以用上面的方法声明内部类实例

```java

TalkingClock jabberer = new Ta1kingClock(1000, true);
TalkingOock . TiiePrinter listener = jabberer .new TimePrinterO；
```



TimePrinter类声明为私有的。这样一来，只有 TalkingClock 的 方 法 才 能 够 构 造TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。



只有内部类才能声明为私有

![image-20201221215212604](image/image-20201221215212604.png)













一个外部类实例可以有多个内部类实例。

```java
class OuterClass {
    int x = 10;

    class InnerClass {
        int y = 5;
    }
}

public class MyMainClass {
    public static void main(String[] args) {
        OuterClass myOuter = new OuterClass();  //必须首先实例化外部类，然后创建内部类的对象来实现。
        OuterClass.InnerClass myInner1 = myOuter.new InnerClass();
        OuterClass.InnerClass myInner2 = myOuter.new InnerClass();

        System.out.println(myInner1 == myInner2); //false
    }
}
```



内部类中声明的所有静态域都必须是 final。

![image-20201221215554813](image/image-20201221215554813.png)

![image-20201221215610242](image/image-20201221215610242.png)

https://blog.csdn.net/weixin_42762133/article/details/82890555



+ 外部类如何访问内部类信息，必须new之后才能访问。

+ 内部类可以直接使用外部类的任何信息，如果属性或者方法发生冲突，调用外部类.this.属性或者方法

+ private 修饰的InnerClass，只能被OuterClass的方法访问

  

  

  

  **内部类是怎么实现的**

  

  ```java
    class OuterClass {
     private int x = 10;
  
      class InnerClass {
          final static int y = 5;
          public void showMessage(){
              System.out.println(x);
          }
      }
  }
  
  public class MyMainClass {
      public static void main(String[] args) {
          OuterClass myOuter = new OuterClass();
          OuterClass.InnerClass myInner = myOuter.new InnerClass();
          myInner.showMessage();
      }
  }
  ```

  我们来分析一下上面的MyMainClass.java这个java文件。编译后生成了三个文件

  ![image-20201221220752402](image/image-20201221220752402.png)

  上面三个文件是编译器帮我们生成的，也就是说虚拟机并不一定支持内部类，而是编译器帮我们实现的内部类。我们通过反编译看看编译器帮我们做了些什么。

  

  ```java
  
  public class MyMainClass {
    public static void main(String[] args) {
      OuterClass myOuter = new OuterClass();
      myOuter.getClass();
      OuterClass.InnerClass myInner = new OuterClass.InnerClass(myOuter);
      myInner.showMessage();
    }
  }
  
  ```

 ```java
//javap -private OuterClass
//Warning: Binary file OuterClass contains base.OuterClass
//Compiled from "MyMainClass.java"
class base.OuterClass {
  private int x;
  base.OuterClass();
  static int access$000(base.OuterClass);
}

 ```

```java
//javap -private OuterClass$InnerClass
//Warning: Binary file OuterClass$InnerClass contains base.OuterClass$InnerClass
//Compiled from "MyMainClass.java"
class base.OuterClass$InnerClass {
  static final int y;
  final base.OuterClass this$0;
  base.OuterClass$InnerClass(base.OuterClass);
  public void showMessage();
}
```

```java
//javap -c OuterClass$InnerClass
//Warning: Binary file OuterClass$InnerClass contains base.OuterClass$InnerClass
//Compiled from "MyMainClass.java"
class base.OuterClass$InnerClass {
  static final int y;

  final base.OuterClass this$0;

  base.OuterClass$InnerClass(base.OuterClass);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #1                  // Field this$0:Lbase/OuterClass;
       5: aload_0
       6: invokespecial #2                  // Method java/lang/Object."<init>":()V
       9: return

  public void showMessage();
    Code:
       0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: aload_0
       4: getfield      #1                  // Field this$0:Lbase/OuterClass;
       7: invokestatic  #4                  // Method base/OuterClass.access$000:(Lbase/OuterClass;)I   看这里看这里
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
      13: return
}
```

虚拟机根本没有内部类的概念，从反编译可以看出编译器修改了我们所编写的，实现了内部类的功能。虚通过把外部类实例引用传递给内部类的内部类来实现我们所想的内部类的逻辑。还有一点需要注意的是，编译器怎么帮我们实现内部类访问外部类的私有域的呢？ 从上面的反编译，反汇编我们可以清楚的看到，是通过静态方法来访外部类的私有域。从`7: invokestatic  #4                  // Method base/OuterClass.access$000:(Lbase/OuterClass;)I ` 这行反汇编可以看出InnerClass的showMessage()方法是通过通过调用OuterClass的静态方法access$000才访问到它的私有域的。

> **在内部类方面，编译器帮做我们做很多。**



**局部内部类**

下面是一个局部内部类的示例

```java

class OuterClass {
    int x = 10;

    public void printSomething(int z){

        class InnerClass implements ActionListener {
            int y = 5;
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println(x+z);
            }
        }
        InnerClass innerClass=new InnerClass();
        Timer t = new Timer(1000, innerClass);

        t.start();

    }

}

public class MyMainClass {
    public static void main(String[] args) {
        OuterClass myOuter = new OuterClass();
        myOuter.printSomething(10);
    }
}
```

```text
10
```



局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。

就拿上面的程序来说，printSomething方法执行完后，actionPerformed方法还没执行，printSomething的方法栈就会释放这个变量。InnerClass类再放执行完之前会给z进行备份。**备份基本类型的数值和引用值**。现在我们来反编译看一下啊编译器做了哪些操作

```java
//javap -private OuterClass$1InnerClass
//Warning: Binary file OuterClass$1InnerClass contains com.base.OuterClass$1InnerClass
//Compiled from "MyMainClass.java"
class com.base.OuterClass$1InnerClass implements java.awt.event.ActionListener {
  int y;
  final int val$z;
  final com.base.OuterClass this$0;
  com.base.OuterClass$1InnerClass();
  public void actionPerformed(java.awt.event.ActionEvent);
}
```

当我们看到` final int val$z;`时就能觉察出，编译器如果发现局部类用到外部的参数就会把局部类增加一个final域。怎么 传给局部类实例呢？

书上的javap构造函数加上了这个final域，我自己反编译的时候并未发现这样。但是这个类又外部类实例的引用和和用到的域对应的变量，他是怎么赋值的?这里值得探索。

但是有些必须有些值需要改变的怎么办。传入对象，int传入Integer也不行，因为Integer是不可变类所以要想改变的内容就相当于改变了引用值，这不符合final域的限制，我们可以传入数组（它是一个对象）。但是现在已经禁止这么做。



**匿名内部类**



将局部内部类的使用再深人一步。 假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类。

匿名类没有类型，不能有构造器，取而代之只能将实例化的参数传递给父类的构造器。

如果是继承父类的匿名类

```java
new SuperType(construction parameters)
{
inner class methods and data
}	
```



如果是实现接口的匿名类，在实现的时候不能有任何参数

```java
new InterfaceTypeQ
l
methods and data
}
```





```java
class OuterClass {
    int x = 10;

    public void printSomething(int z){

        Timer t = new Timer(1000, new ActionListener(){

            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println(x+z);
            }
        });

        t.start();

    }
```

```java
//javap -c OuterClass$1
//Warning: Binary file OuterClass$1 contains com.base.OuterClass$1
//Compiled from "MyMainClass.java"
class com.base.OuterClass$1 implements java.awt.event.ActionListener {
  final int val$z;

  final com.base.OuterClass this$0;

  com.base.OuterClass$1(com.base.OuterClass, int);  //把外部类当引用和用到的val$z都传了进去。
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #1                  // Field this$0:Lcom/base/OuterClass;
       5: aload_0
       6: iload_2
       7: putfield      #2                  // Field val$z:I
      10: aload_0
      11: invokespecial #3                  // Method java/lang/Object."<init>":()V
      14: return

  public void actionPerformed(java.awt.event.ActionEvent);
    Code:
       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: aload_0
       4: getfield      #1                  // Field this$0:Lcom/base/OuterClass;
       7: getfield      #5                  // Field com/base/OuterClass.x:I
      10: aload_0
      11: getfield      #2                  // Field val$z:I
      14: iadd
      15: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
      18: return
}
```

















> “ 双括号初始化” （ double brace initialization)

```java
ArrayList<String> friends = new ArrayListoO；
friends.add("Harry");
friends.add("Tony");
invite(friends);
```

使用匿名内部类语法

```java
invite(new ArrayList<String>() {{ add("Harry"); add("Tony"); }});
```

这个匿名内部类没有重写父类的方法，而是在父类的基础上加了一个构造快。 内层括号则是一个对象构造块。

我们来反编译看看到底发生了什么事情？

```java
public class MyMainClass {
    public static void main(String[] args) {

        ArrayList<String> friends= new ArrayList<String>() {{ add("Harry"); add("Tony"); }};
        System.out.println(friends.size());
    }
}
```

反编译上面的(JD-gui反编译)

```java
//MyMainClass.class
import java.util.ArrayList;

public class MyMainClass {
  public static void main(String[] args) {
    ArrayList<String> friends = new ArrayList<String>(10) {
      
      };
    System.out.println(friends.size());
  }
}


//MyMainClass$1.class

import java.util.ArrayList;

final class null extends ArrayList<String> {
  null() {
    add("Harry");
    add("Tony");
  }
}

```

我们修改一下MyMainClass.java

```java
public class MyMainClass {
    public static void main(String[] args) {

        ArrayList<String> friends= new ArrayList<String>(10) {{ add("Harry"); add("Tony"); }};
        System.out.println(friends.size());
    }
}
```

我们再来反编译一下

```java
import java.util.ArrayList;

public class MyMainClass {
  public static void main(String[] args) {
    ArrayList<String> friends = new ArrayList<String>(10) {
      
      };
    System.out.println(friends.size());
  }
}
```

```java
import java.util.ArrayList;

final class null extends ArrayList<String> {
  null(int x0) {
    super(x0);
    add("Harry");
    add("Tony");
  }
}
```

**静态内部类**

使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为 static, 以便取消产生的引用。

和在外部定义一样，除了访问权限没有任何区别。

>  声明在接口中的内部类自动成为 static 和 public 类。

可以减少类名字冲突，方便编程

### 4.4 代理







## **第五章 异 常 、 断 言 和 曰 志**



## 第六章 泛型程序设计

> **泛型为了代码更好的重用**



### 6.1**泛型类**

​		就拿ArrayList来说吧，在很久很久以前，ArrayList类在定义的时候，为了重用代码，它里面的存储的元素是Object，这样我们就可以存储任何类型的元素。但是这样容易造成混乱，比如说声明了一个ArrayList实例，它就可以同时存储String和Integer。这种情况特别混乱会容易导致我们出错。

​	 所以我们的泛型就出现了，泛型是怎么回事呢？直接看下面例子。

```java
public class Pair<T>
{
    private T first;
    private T second;
    public Pair() { first = null ; second = null ; }
    public Pair(T first, T second) { this,first = first; this.second = second; }
    public T getFirst() { return first; }
    public T getSecond() { return second; }
    public void setFirst(T newValue) { first = newValue; }
    public void setSecond(T newValue) { second = newValue; }
}
```

上面就引入了一个泛型变量T,我们来看看他怎么使用。

```java
Pair<String> strPair=new Pair<String>();
```

上面的实例化就相当于实例下面一个类

```java
public class Pair
{
    private String first;
    private String second;
    public Pair() { first = null ; second = null ; }
    public Pair(String first, String second) { this,first = first; this.second = second; }
    public String getFirst() { return first; }
    public String getSecond() { return second; }
    public void setFirst(String newValue) { first = newValue; }
    public void setSecond(String newValue) { second = newValue; }
}
```

这就是泛型的力量。

如果引入多个泛型变量,就在尖括号后面引入	。

``` java
public class Pair<T, U> { . . . }
```

K 和 V 分别表示表的关键字与值的类型。T ( 需要时还可以用临近的字母 U 和 S) 表示“ 任意类型”。

### 6.2泛型方法



class <T>  需要从类中确定的类型

方法中的<T> 需要从参数确定的类型

```java
public static <T> T getMiddle(T ... a)
{
    return a[a.length / 2];
}
```



泛型方法可以定义在普通类中，也可以定义在泛型类中。

在普通类里面的泛型变量要想让编译器推导出是什么是具体类型，只能在调用的时候从参数入手。



### 6.3 类型变量的限定

有时候我们在写一个泛型类的时候，对输入的类有一些限制。比如我们做一个泛型类，但是输入的类型必须实现某个接口或者继承某个父类，
就像下面，我们输入的这个类必须实现comparable接口，我么必须做一些限制。

![image-20201224225422929](image/image-20201224225422929.png)

利用extends关键字进行限制，这包含了限制实现和继承。（为了减少不必要的繁琐，实现和继承没有去区分关键字）。

```java
public class ArrayAIg {
    public static <T extends Comparable> T min(T[] a)
    {
        if (a == null || a.length== 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a . length; i++)
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        return smallest;
    }
}

```

如果想做多个限制，这样写   `T extends Comparable & Serializable`

> 限定类型用“ &” 分隔，而逗号用来分隔类型变量。



### 6.4 泛型代码和虚拟机

​	虚拟机里没有泛型类对象---所有的对象都是普通类（这一点在内部类里里面有一定的证实）。

那么泛型是怎么实现的呢？？？？

**类型擦除**

为了兼容以前的代码，一些新特性都不会修改虚拟机一般都是在编译期间做了一些”手脚“，有一种帮助你写代码的感觉。编译器在编译好给虚拟机的时候都会把泛型的类型擦除然后做一些处理。具体是怎么做的处理呢？



我们写的：

```java
public class Pair<T>
{
    private T first;
    private T second;
    public Pair(Object first, T second) 
    {
        this.first = first;
        this.second = second;
    }
    public Pair(T first, T second) { this,first = first; this.second = second; }
    public T getFirst() { return first; }
    public T getSecond() { return second; }
    public void setFirst(T newValue) { first = newValue; }
    public void setSecond(T newValue) { second = newValue; }
    public static void main(String[] args) {
        Pair<String> strPair=new Pair<>();
        strPair.setFirst("str1");
       String str= strPair.getFirst();
    }
}
```

被编译器处理过的：

```java
public class Pair
{
    private Object first;
    private Object second;
    public Pair(Object first, Object second)
    {
        this.first = first;
        this.second = second;
    }
    public Object getFirst() { return first; }
    public Object getSecond() { return second; }
    public void setFirst(Object newValue) { first = newValue; }
    public void setSecond(Object newValue) { second = newValue; }
    public static void main(String[] args) {
       Pair strPair=new Pair();
       strPair.setFirst("str1");
       String str= (String)strPair.getFirst();
    }
}
```

> 类型擦除泛型替换为原始类型,有些地方做了强制类型转化。



原始类型用第一个限定的类型变量来替换，如果没有给定限定就用 Object 替换。 例如，类 Pair<T> 中的类型变量没有显式的限定，因此，原始类型用 Object 替换 T。假定声明了一个不同的类型。

有些情况如果用第一个限制类型(Comparable)，但是泛型类代码中用到其他类型(Runable)的限定符的特性编译器怎么办？做强制类型。（强制类型转化肯定安全，要不编译通不过）



**翻译泛型表达式**

 `  String str= (String)strPair.getFirst();`

+ 对原始方法 Pair.getFirst 的调用。
+ 将返回的 Object 类型强制转换为 String类型。                  

这些 上面已经了解到



**翻译泛型方法**

```java
public class Datelnterval extends Pair<LocalDate>{

    @Override
    public void setSecond(LocalDate newValue) {
        if (second.compareTo(getFirst()) >= 0)
            super.setSecond(second);
    }

}
```

上面这个方法泛型擦除后会变成什么样呢？

```java
public class Pair
{
    private Object first;
    private Object second;
    public Pair(Object first, Object second)
    {
        this.first = first;
        this.second = second;
    }
    public Object getFirst() { return first; }
    public Object getSecond() { return second; }
    public void setFirst(Object newValue) { first = newValue; }
    public void setSecond(Object newValue) { second = newValue; }
    public static void main(String[] args) {
       Pair strPair=new Pair();
       strPair.setFirst("str1");
       String str= (String)strPair.getFirst();
    }
}
```



```java
class Datelnterval extends Pair {// after erasure
	public void setSecond(LocalDate second) { . . . }
}

```

这样的话，Datelnterval并没有重写setSecond方法，这就会出现一个问题

```java
Datelnterval interval = new Datelnterval( . . . );
Pair<Loca1Date> pair = interval; // OK assignment to superclass
pair.setSecond(aDate);
```

 由于 pair 引用Datelnterval 对象，所以应该调用 Datelnterval.setSecond,但是情况不是这样的。因为并没有重写的setSecond方法，虚拟机会认为Datelnterval有两个setsecond方法，一个是父类继承来的一个自己声明的。这样的话他会直接调用继承父类的那个方法。编译器会怎么处理这个问题呢？



编译器在 Datelnterval 类中生成一个桥方法 （bridge method):   public void setSecond(Object second) { setSecond((Date) second); 就相当于重写了这个方法.我们来反汇编看一下这个Datelnterval .class

```java
//javap -c Datelnterval
//Warning: Binary file Datelnterval contains com.base.Datelnterval
//Compiled from "Datelnterval.java"
public class com.base.Datelnterval extends com.base.Pair<java.time.LocalDate> {
  public com.base.Datelnterval();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method com/base/Pair."<init>":()V
       4: return

  public void setSecond(java.time.LocalDate);
    Code:
       0: aload_0
       1: getfield      #2                  // Field second:Ljava/lang/Object;
       4: checkcast     #3                  // class java/time/LocalDate
       7: aload_0
       8: invokevirtual #4                  // Method getFirst:()Ljava/lang/Object;
      11: checkcast     #5                  // class java/time/chrono/ChronoLocalDate
      14: invokevirtual #6                  // Method java/time/LocalDate.compareTo:(Ljava/time/chrono/ChronoLocalDate;)I
      17: iflt          28
      20: aload_0
      21: aload_0
      22: getfield      #2                  // Field second:Ljava/lang/Object;
      25: invokespecial #7                  // Method com/base/Pair.setSecond:(Ljava/lang/Object;)V
      28: return

  public void setSecond(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: checkcast     #3                  // class java/time/LocalDate
       5: invokevirtual #8                  // Method setSecond:(Ljava/time/LocalDate;)V
       8: return
```

上面编译器帮我们做的桥接方法。就可以在程序员的视角上，比较合乎清理了。，

我们能自己重写这个方法吗？我们试试看

![image-20201226213258810](image/image-20201226213258810.png)

从上面的报错来看，显然是不能的。从程序员的角度来说我们已经重写了这个方法。提示显示的错误很清楚

`'setSecond(T)' in 'com.base.Pair' clashes with 'setSecond(Object)' in 'com.base.Datelnterval'; both methods have same erasure, yet neither overrides the other`





**调用遗留代码**



通过编译器，在交给虚拟机之前做的处理可以发现，对在没有出现泛型之前的代码完全是兼容的。





### 6.5 约束性和局限性

**不能用基本类型实例化类型参数**

因为泛型擦除后是以Object呈现给虚拟机的，所以基本类型是不行的。



**运行时类型查询只适用于原始类型**

因为虚拟器里面没有泛型的概念，运行的时候有关泛型的类型操作都不是支持的

`if (a instanceof Pair<String>) // Error`

`if (a instanceof Pair<T>) // Error`

`Pair<Sring> = (Pair<String>) ; // Warning - can only test that a is a Pai`

同样的道理，getClass 方法总是返回原始类型。例如：

```java
Pair<String> stringPair = ...
Pair< Employee 〉 employeePair = ...
if (stringPair.getClass() == employeePair.getClass()) // they are equal
```

![image-20201226215223334](image/image-20201226215223334.png)

**不能创建参数化类型的数组**

![image-20201226215715555](image/image-20201226215715555.png)

**Varargs 警告**

public static <T> void addAll(Collections coll, T ... ts)
{
for (t : ts) coll . add⑴；
}为了调用这个方法，Java 虚拟机必须建立一个 Pair<String> 数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。

 **不能实例化类型变置**

不能使用像 new T(...)，newT[...] 或 T.class 这样的表达式中的类型变量。 类型擦除将 T 改变成 Object, 而且，本意肯定不希望调用 new Object()。那我们遇到这种情况应该怎么办？可以利用 Class来完成泛型的实例化。

```java
public static <T> Pai r<T> makePair(Cl ass<T> cl)
{
    try { return new Pairo(d .newInstanceO . cl . newInstanceO )；}
    catch (Exception ex) { return null; }
}
Pair<String> p = Pair.makePair(String.class);
```

Class 类本身是泛型。 例如，String.daSS 是一个 Class<String> 的实例（事实上，它是唯一的实例 )。因此，makePair 方法能够推断出 pair 的类型。

**不能构造泛型数组**



**泛型类的静态上下文中类型变量无效**

```java
public class Singleton<T>
{
private static T singlelnstance; // Error
public static T getSinglelnstanceO // Error
{
if (singleinstance == null) construct new instance of T
return singlelnstance;
}
}
```



如果上面的代码能运行，你会发现调用的时候T无法被推断出。

**不能抛出或捕获泛型类的实例**

```java
public class Problem<T> extends Exception { /* . . . */ } // Error can' t extend Throwable
```



**可以消除对受查异常的检查**

**注意擦除后的冲突**

**泛型类型的继承规则**













### 6.6泛型类型的继承规则

![image-20201226221702379](image/image-20201226221702379.png)

![image-20201226221730115](image/image-20201226221730115.png)

### 6.7通配符类型

通配符类型中，允许类型参数变化。 例如，通配符类型Pair<? extends Employee 〉

表示任何泛型 Pair 类型，它的类型参数是 Employee 的子类，如 Pair<Manager>，但不是Pair<String> 。



 **通配符的子类型限定**

下面举一个场景，让我们感受一下通配符的好处



假设要编写一个打印雇员对的方法，像这样：

```java
public static void printBuddies(Pair<Employee> p)
{
	Employee first = p . getFirst();
	Employee second = p . getSecond();
	Systefn . out . println(first . getName() + " and " + second . getName() + " are buddies . ");

}
```

不能将 Pair<Manager> 传递给这个方法，这一点很受限制。解决的方法很简单：使用通配符类型：

```java
public static void printBuddies(Pair<<? extends Eiployee> p)
{
	Employee first = p . getFirst();
	Employee second = p . getSecond();
	Systefn . out . println(first . getName() + " and " + second . getName() + " are buddies . ");

}
```

![image-20201226222838427](image/image-20201226222838427.png)

我们来看下面的对限定符的使用

```java
Pair<Manager> managerBuddies = new PairoCceo, cfo) ;
Pair<? extends Employee> wildcardBuddies = manage rBuddies; // OK
wi1dcardBuddies.setFirst(1owlyEnployee); // compile - time error
```

Pai r<? extends Employee>的方法在我们理解下可能是这样的

? extends Employee getFi rst()
void setFirst(? extends Employee)

这样将不可能调用 setFirst 方法。编译器只知道需要某个 Employee 的子类型，但不知道具体是什么类型。它拒绝传递任何特定的类型。毕竟？不能用来匹配。使用 getFirst 就不存在这个问题： 将 getFirst 的返回值赋给一个 Employee 的引用完全合法。这就是引人有限定的通配符的关键之处。现在已经有办法区分安全访问器方法和不安全的更改器方法了。









**通配符的超类型限定**



### 6.8反射和泛型

































## 第七章 集合



### 7.1 Java 集合框架

​		Java 最初版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、 Hashtable、BitSet 与 Enumeration 接口，其中的 Enumeration 接口提供了一种用于访问任意容器中各个元素的抽象机制。这是一种很明智的选择，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。

在java标准库里面我们经常见这样的组合  接口 （ interface) 与 实 现分离。就拿队列距离来说	

```java
public interface Queue<E> // a simplified form of the interface in the standard library
{
	void add(E element);
	E remove();
	int size()；
}
```

这个接口只是把队列的一些功能表达出来了，并没有展示这个队列是怎么实现的。队列通常的实现方式 一种是循环数组 一种是链表。

![image-20201226225225235](image/image-20201226225225235.png)****



​			当我们用使用接口变量去引用一个实例的时候，我们不必去关心他们是怎么实现的。按照接口提供的规则去使用即可。在研究 API 文档时，会发现另外一组名字以 Abstract 开头的类，例如，AbstractQueue。这些类是为类库实现者而设计的。 如果想要实现自己的队列类（也许不太可能 )，会发现扩展AbstractQueue 类要比实现 Queue 接口中的所有方法轻松得多。

​			一个接口一个抽象类（很常见），这种组合的可以让编程人员专注那些需要实现那些自己实现的方法，因为有些方法具有通用性。可以通过组合一些基础方法进行实现。

**Collection接口**

```java

public interface Collection<E> extends Iterable<E> {
    
    
    /**
     * Returns an iterator over the elements in this collection.  There are no
     * guarantees concerning the order in which the elements are returned
     * (unless this collection is an instance of some class that provides a
     * guarantee).
     *
     * @return an <tt>Iterator</tt> over the elements in this collection
     */
    Iterator<E> iterator();
    
    // Modification Operations

    /**
     * Ensures that this collection contains the specified element (optional
     * operation).  Returns <tt>true</tt> if this collection changed as a
     * result of the call.  (Returns <tt>false</tt> if this collection does
     * not permit duplicates and already contains the specified element.)<p>
     *
     * Collections that support this operation may place limitations on what
     * elements may be added to this collection.  In particular, some
     * collections will refuse to add <tt>null</tt> elements, and others will
     * impose restrictions on the type of elements that may be added.
     * Collection classes should clearly specify in their documentation any
     * restrictions on what elements may be added.<p>
     *
     * If a collection refuses to add a particular element for any reason
     * other than that it already contains the element, it <i>must</i> throw
     * an exception (rather than returning <tt>false</tt>).  This preserves
     * the invariant that a collection always contains the specified element
     * after this call returns.**/
    
    boolean add(E e);

}
```

一个添加元素的方法，一个返回迭代器，遍历访问元素的时候使用

**迭 代 器**

```java
/**
 * An iterator over a collection.  {@code Iterator} takes the place of
 * {@link Enumeration} in the Java Collections Framework.  Iterators
 * differ from enumerations in two ways:
 *
 * <ul>
 *      <li> Iterators allow the caller to remove elements from the
 *           underlying collection during the iteration with well-defined
 *           semantics.
 *      <li> Method names have been improved.
 * </ul>**/


public interface Iterator<E>
{
    
      /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration
     * @throws NoSuchElementException if the iteration has no more elements
     */
    E next();
    
    /**
     * Returns {@code true} if the iteration has more elements.
     * (In other words, returns {@code true} if {@link #next} would
     * return an element rather than throwing an exception.)**/
    boolean hasNext();
    
    
    /**
     * Removes from the underlying collection the last element returned
     * by this iterator (optional operation).  This method can be called
     * only once per call to {@link #next}.  The behavior of an iterator
     * is unspecified if the underlying collection is modified while the
     * iteration is in progress in any way other than by calling this**/
        default void remove() {throw new UnsupportedOperationException("remove");}
    
     /**************************************************************************
     * Performs the given action for each remaining element until all elements *
     * have been processed or the action throws an exception.  Actions are	   *
     * performed in the order of iteration, if that order is specified.        *
     * Exceptions thrown by the action are relayed to the caller.			   *
     ***************************************************************************/
    
    default void Remaining(Consumer<? super E> action);
}
```



1.通过反复调用 next 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，next 方法将抛出一个 NoSuchElementException。

2.如果迭代器还可以往下遍历访问元素，就返回true；这就避免了上面的那个异常

 ``` java
Collection<String> c = . . .;
Iterator<String> iter = c.iterator();
while (iter.hasNext())
{
    String element = iter.next();
    do something with element
}
 ```

 上面的便利可以用更简练的for-each，for-each就是用itrator来实现的。编译器简单地将“  ” 循环翻译为带有迭代器的循环。

```java
for (String element : c)  //c 必须实现Iterable接口。
{
	do something with element
}

```

```java

/**
 * Implementing this interface allows an object to be the target of
 * the "for-each loop" statement.**/
public interface Iterable<T> {
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    Iterator<T> iterator();
        /**
     * Performs the given action for each element of the {@code Iterable}
     * until all elements have been processed or the action throws an
     * exception.  Unless otherwise specified by the implementing class,
     * actions are performed in the order of iteration (if an iteration order
     * is specified).  Exceptions thrown by the action are relayed to the
     * caller.
     *
     * @implSpec
     * <p>The default implementation behaves as if:
     * <pre>{@code
     *     for (T t : this)
     *         action.accept(t);
     * }</pre>
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @since 1.8
     */
    default void (Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
    
    }
```

Collection 接口扩展了 Iterable 接口。因此，对于标准类库中的任何实现Collection 的集合都可以使用“ ” 循环。



实现这个接口，实例的对象就会允许使用  语句遍历（说明是通过迭代器实现的）

3.Remaining

```java
 iterator.Remaining(el ement - > do something with element);
```

​	iterator解析来访问那些还未访问的元素，并执行一些操作。

​	元素被访问的顺序取决于集合类型。 如果对 ArrayList 进行迭代，迭代器将从索引 0 开始，每迭代一次，索引值加 U 然而，如果访问 HashSet 中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说，并不是什么问题。

如果你细心，你可能发现Iterable也有这个方法，其实效果是一样。



迭代器是怎么访问元素的呢？对于很难想象迭代器是怎么工作的，可以参考下面的思考角度

应该将 Java 迭代器认为是位于两个元素之间。 当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用（见图 9 - 3 ) 





![image-20201226235056454](image/image-20201226235056454.png)



remove()调用之前必须调用next()方法。并且调用这两个方法之间没有remove操作。

it . next();

it . remove();
it . remove(); // Error!

必须交替出现

it . next();

it . remove();

it . next();

it . remove(); // Error!

如果调用 remove 之前没有调用 next 将是不合法的。 如果这样做，将会抛出一个 IllegalStateException 异常。

**泛型实用方法**

由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。

```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAl1 (Col1ection<?> c)
boolean equals(Object other)
boolean addAll (Collection<? extends E> from)
boolean remove(Object obj)
boolean removeAll (Col1ection<?> c)
void clear()
boolean retainAll (Col1ection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
```

如果实现一个Collection接口都要把这些方法实现是一件很麻烦的事情。还记得我们前面的提到的一个接口一个抽象类的组合吗？

```java
public abstract class Abstracted1ection< E>
implements Collection< E>
public abstract Iterator< E> iterator() ;
public boolean contai ns(Object obj)
{
	for (E element : this) // calls iterator()
	if (element.equals (obj))
	return = true;
	return false;
}
```

`Abstracted1ection` 已经把比较通用的方法实现，已经实现了。这样我们剩下一些繁琐的麻烦。

> ​		对于 Java SE 8, 这种方法有些过时了。 如果这些方法是 Collection 接口的默认方法会更好。 但实际上并不是这样。不过，确实已经增加了很多默认方法。其中大部分方法都与流的处理有关（有关内容将在卷 n 中讨论）。 另外，还有一个很有用的方法：default boolean removelf (Predicate<? super E> filter)这个方法用于删除满足某个条件的元素。







下面我们来简单介绍一下API



![image-20201227001056086](image/image-20201227001056086.png)





![image-20201227001120852](image/image-20201227001120852.png)

![image-20201227001136621](image/image-20201227001136621.png)





**集 合 框 架 中 的 接 口**

![image-20201227001252597](image/image-20201227001252597.png)



容器有两大家族Collection和Map，Map是一个映射存储的结构，key-value的存储，Collection的需要add 增加容器内的元素。Map需要下面的方法。

```java
/**
* Associates the specified value with the specified key in this map
* (optional operation).  If the map previously contained a mapping for
* the key, the old value is replaced by the specified value.  (A map
* <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only
* if {@link #containsKey(Object) m.containsKey(k)} would return
* <tt>true</tt>.)*/

V put(K key, V value);
```

要从Collection中读取元素，可以用迭代器访问元素。不过，从Map中读取值则要使用 get 方法：

```java
V get(Object key);
```

---LIst

​		List 是一个有序集合（ordered collection），元素增加到容器的特定位置。可以采取两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问（random access）。严格意义上讲List中的ArrayList支持随机访问，LinkedList的随机访问只是通过遍历来实现的，不是真正意义上的随机访问。

Listlterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素
void add(E element);为什么Iterator 的没有这个方法？因为别的集合是无序集合，没有在一个特定的位置增加一个元素。没有特定位置的这个概念。

Set 接口在方法签名方面等同于 Collection 接口，为什么还要建一个这样的接口呢？

```java

/**
 * A collection that contains no duplicate elements.  More formally, sets
 * contain no pair of elements <code>e1</code> and <code>e2</code> such that
 * <code>e1.equals(e2)</code>, and at most one null element.  As implied by
 * its name, this interface models the mathematical <i>set</i> abstraction.*/

public interface Set<E> extends Collection<E> {
    
}
```

他的方法的实现在条件上更加适合自己的这个特征。 从概念上讲，并不是所有集合都是集。建立一个 Set 接口可以让程序员编写只接受集的方法，更好的实现集的方法。





### 7.2 具体的集合

![image-20201227151915752](image/image-20201227151915752.png)



在表 9 - 1 中，除了以 Map 结尾的类之外，其他类都实现了 Collection 接口，而以 Map 结尾的类实现了 Map 接口。

![image-20201227152049894](image/image-20201227152049894.png)















**链 表（LinkedList）**

数组和Array List都有一个很大的缺陷，就是在列表中删掉一个元素。就要移动一大推元素。这是一个非常耗时的一个操作。



![image-20201227152752395](image/image-20201227152752395.png)

LinkedList解决这个删除元素很耗时的问题





![image-20201227152912755](image/image-20201227152912755.png)

在java中所有的链表都是双向链表，从链表中间删除一个元素是一个很轻松的操作。



![image-20201227153022398](image/image-20201227153022398.png)



。LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，下一节将要讨论的集 （set) 类型，其中的元素完全无序。因此，在 Iterator 接口中就没有add 方法。相反地，集合类库提供了子接口 Listlterator, 其 中 包 含 add 方 法：



```java
interface ListIterator<E> extends Iterator<E>
{
	void add(E element);
    boolean hasPrevious(); 
    E previous();
}
```

`E previous()`  `boolean hasPrevious()`两个方法用来反向遍历列表。与next方法一样,precious不过是向前越过对象。

```java
ListIterator<String> iter = staff.listlterator();
```



![image-20201227164224293](image/image-20201227164224293.png)





|ABC
A|BC
AB|C
ABC|

上面的光标的位置表示ListIterator的位置，有四个位置我们可以添加元素。所以说n个元素，我们将会有n+1的位置添加元素。



>调用 next 之后，remove 方法确实与 BACKSPACE 键一样删除了迭代器左侧的元素。但是，如果调用 previous 就会将右侧的元素删除掉，并且不能连续调用两次remove ()

观察remove ()用法，我们更能印象深刻。无论是调用next 还是previous ，都是删除的越过的元素。

>add 方法只依赖于迭代器的位置，而 remove 方法依赖于迭代器的状态。

下面还有一点需要注意。

```java
List<String> list = . . .
ListIterator<String> iterl = list.listlterator();
ListIterator<String> iter2 = list.listlterator();
iterl.next();
iterl.remove()；
iter2.next(); // throws ConcurrentModificationException
```

由于 iter2 检 测 出 这 个 链 表 被 从 外 部 修 改 了，所 以 对 iter2.next 的 调 用 抛 出 了 一 个Concurrent ModificationException 异常。

为什么会设置抛出这种异常呢？

例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。 如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个ConcurrentModificationException 异常。



我怎么设计才能让它抛出这异常呢？

参考书上



> get 方法做了微小的优化：如果索引大于 size() / 2 就从列表尾端开始搜索元素。

API

![image-20201227165904476](image/image-20201227165904476.png)



![image-20201227165913353](image/image-20201227165913353.png)



![image-20201227165932065](image/image-20201227165932065.png)



**数组列表（ArrayList）**

数组实现的List

**散列集（HashSet）**

无论是列表还是数组在查找一个对象的时候都需要遍历才能找到，这样做确实比较耗费性能。

HashSet在查找元素的时候就很快，他到底是怎么实现的呢？

就是散列表的思想 hash table的思想，散列表为每个对象计算出一个整数，成为散列码（hashcode）。

在hashcode是根据对象的实例产生的一个整数，在java中每个对象都有一个hashcode方法。

![image-20201227173026297](image/image-20201227173026297.png)

HashSet用链表数组实现，每个列表被称为桶（bucket）如上图所示。上面图示就是它的真实存储结构。他是依靠什么什么规则放到这个存储结构呢？才能保证元素快速的被访问到。

如果某个对象的散列码为 76268, 并且有 128 个桶，对象应该保存在第 108 号桶中（ 76268除以 128 余 108 )。 或许会很幸运，在这个桶中没有
其他元素，此时将元素直接插人到桶中就可以了。

当然，有时候会遇到桶被占满的情况，这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 解决冲突有很多方式，我们将在数据结构里面会学到各种解决冲突的方式。HashSet是用到的是**拉链法**

当我们遇见Hash冲突的时候需要用新对象与桶中的所有对象进行比较，査看这个对象是否已经存在。

> 在java8中链表的长度达到一定数值的时候就会从链表变成了平衡二叉树

当HashSet中达到一定数量的元素的时候，冲突就会原来越多，这样会增加访问元素的时间，损耗性能。这时候我们就不得不增加桶的数量（扩容）。对元素进行再哈希（rehash）到底什么情况下增加桶的数量才是最适合的呢？

装填因子决定什么时候对hashSet扩容。0.75。 当 size （元素个数）> threshold（加载因子）*CAPACITY（桶的数量）时候进行扩容

HashSet和Hashmap有一定的关系，具体的实现细节将在源码分析中，说明。



![image-20201227174747721](image/image-20201227174747721.png)



**TreeSet**

 TreeSet类与HasnSet功能相似。但是它是一个有序集合，没错就是一个有序集合。不是线性的不一定就不是有序集合，他里面的元素都一个按照比较严格的规则进行排列的。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。

类如其名它的底层是通过Tree实现的，是红黑树。红黑树的原理见数据结构与算法。

查找元素很快，这就依靠的是他底层结构。红黑树查找元素的复杂度都是Log2^n,跟数的高度相关。但是添加元素的时候却要精确判断每个对象的位置，所以需要很耗费时间。





![image-20201227180546254](image/image-20201227180546254.png)

>  TreeSet 类实现了 NavigableSet 接口。 这个接口增加了几个便于定位元素以及反向遍历的方法。

![image-20201227180553880](image/image-20201227180553880.png)



**队列与双端队列**

在 Java SE 6 中引人了 Deque 接口，并由 ArrayDeque 和LinkedList 类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。





![image-20201227180756304](image/image-20201227180756304.png)	

![image-20201227180806212](image/image-20201227180806212.png)

![image-20201227180812987](image/image-20201227180812987.png)





**优先级队列（PriorityQueue**

优先级队列（priority queue) 中的元素可以按照任意的顺序插人，却总是按照排序的顺序进行检索。他是怎么做的呢？

还是依靠它的底层实现。优先级队列使用了一个优雅且高效的数据结构，称为堆（ heap)。堆是一个可以自我调整的二叉树，对树执行添加 （ add) 和删除（ remore) 操作后，需要对堆的结构进行调整，可以让最小的元素移动到根，而不必花费时间对元素进行排序。              （大顶堆，小顶堆）

学了堆排序就会恍然开朗。

怎么比较呢？？？

与 TreeSet — 样，一个优先级队列既可以保存实现了 Comparable 接口的类对象，也可以保存在构造器中提供的 Comparator 对象。



![image-20201227181751269](image/image-20201227181751269.png)





### 7.3  映射



Map是用来存放键值对，并且可以通过键能很快找到元素。

**基 本 Map操作 **

java类库为大家提供了两种比较经常使用的实现，那就是HashMap和Treemap,都实现了Map接口。

HashMap对key进行散列，散列或比较函数只能作用于键。用键的整体顺序对元素进行排序，并将其组织成搜索树

应该选择HashMap还是TreeMap呢？ 与Set一样，HashMap稍微快一些，如果不需要按照排列顺序访问键，就最好选择HashMap。

每当往映射中添加对象时，必须同时提供一个键。看下面的方法

```java
/**
 * Associates the specified value with the specified key in this map
 * (optional operation).  If the map previously contained a mapping for
 * the key, the old value is replaced by the specified value.  (A map
 * <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only
 * if {@link #containsKey(Object) m.containsKey(k)} would return
 * <tt>true</tt>.)**/
V put(K key, V value);
```

键必须是唯一的。不能对同一个键存放两个值。 如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上
，put 将返回用这个键参数存储的上一个值。



要想检索一个对象，必须使用一个键。



```java
/**
 * Returns the value to which the specified key is mapped,
 * or {@code null} if this map contains no mapping for the key.
 */
V get(Object key);
```

![image-20201227214611514](image/image-20201227214611514.png)

![image-20201227214624699](image/image-20201227214624699.png)

![image-20201227214640723](image/image-20201227214640723.png)





**更新映射项**

举一个例子：使用一个映射统计一个单词在文中出现的频度。当看到一个单词我们将计数器增1。

```java
counts.put(word, counts.get(word)+ 1);
```

不过有一种情况除外： 就是第一次看到 word 时。在这种情况下，get 会返回 null, 因此会出现一个 NullPointerException 异常。

下面是补救措施:

```java
counts.put(word, counts.getOrDefault(word, 0)+ 1);
```

第二种方法：

```java
counts.putlfAbsent(word, 0);
counts.put(word, counts.get(word)+ 1); // Now we know that get will succeed

```

```java
/* <p>The default implementation makes no guarantees about synchronization
     * or atomicity properties of this method. Any implementation providing
     * atomicity guarantees must override this method and document its
     * concurrency properties.*/
     
default V putIfAbsent(K key, V value) {
    V v = get(key);
    if (v == null) {
        v = put(key, value);
    }
    return v;
    
}
```







```java
counts.merge(word, 1, Integer::sum);
```

这个方法是上面的简略写法

```java

/**
     * If the specified key is not already associated with a value or is
     * associated with null, associates it with the given non-null value.
     * Otherwise, replaces the associated value with the results of the given
     * remapping function, or removes if the result is {@code null}. This
     * method may be of use when combining multiple mapped values for a key.
     * For example, to either create or append a {@code String msg} to a
     * value mapping:
     *
     * <pre> {@code
     * map.merge(key, msg, String::concat)
     * }</pre>**/

default V merge(K key, V value,
        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    Objects.requireNonNull(value);
    V oldValue = get(key);
    V newValue = (oldValue == null) ? value :
               remappingFunction.apply(oldValue, value);
    if(newValue == null) {
        remove(key);
    } else {
        put(key, newValue);
    }
    return newValue;
}
```

![image-20201227220909641](image/image-20201227220909641.png)

​	











**映射视图**

Map有三种视图，通过以下方法获得。

```java
Set<K> keySet()   // 一种不同于HashSet和TreeSet的Set  ---- 键集视图
Collection<V> values()						//     ---- 值集视图
Set<Map.Entry<K, V> entrySet()              //     ---- 键值对集合视图
    
```

```java

Set<String> keys = map . keySetO;
for (String key : keys)
{
	do something with key
}	


//同时查看键和值，可以通过枚举条目来避免查找值。
for (Map . Entry<String, Employee 〉 entry : staff . entrySetO)
{
	String k = entry . getKeyO；
	Employee v = entry . getValueO;
	do something with k, v
}

//上面的方法以前是写起来最简便的方法，现在可以用以下的方式进行书写
counts.((k， v)-> {
dosomethingwith k, v
});
```

如果在键集视图上调用迭代器的 remove 方法，**实际上会从映射Map中删除这个键和与它关联的值。不过，不能向键集视图增加元素（ UnsupportedOperationException）。**

![image-20201228000939523](image/image-20201228000939523.png)



我们在使用java类（hashMap,Treemap）库中那些类的时候，不需要考虑上面返回的Set Collection是怎么实现的，就按照规则使用他那些方法功能就好，因为这些方法已经是一种规则，我们也知道是怎么用的。

**弱散列映射**

假设有一个键值对已经使用完了，以后再也不会使用它了。但是他还一直在Map中，又因为由于Map的结构，这个键值对一直被引用着。这样就会导致垃圾回收器就不会对它进行回收，那么这样就会导致内存泄漏。为了解决这种场景java类库提供一种数据结构-------WeakHashMap。

 当对键的唯一引用来自WeakHashMap时，这一数据结构将与垃圾回收器协同工作一起删除键 / 值对。

> WeakHashMap 使用弱引用 （ weak references) 保存键来实现这种及时回收对象的效果，应用时注意使用场景。



**链接散列集与映射**

LinkedHashSet和LinkedHashMap 用来记住元素项的顺序。通过增加两个引用指向它的前一个节点的对象和后一个节点的对象，从而生成一个双向对类

![image-20201228141230667](image/image-20201228141230667.png)

通俗的来讲，就是HashMap里面还隐藏一个双向队列。这队列是以什么顺序排列的呢？

这里面有一个参数很重要。

```java

  /**
     * The iteration ordering method for this linked hash map: <tt>true</tt>
     * for access-order, <tt>false</tt> for insertion-order.
     *
     * @serial
     */
    final boolean accessOrder;

/**
 * Constructs an empty <tt>LinkedHashMap</tt> instance with the
 * specified initial capacity, load factor and ordering mode.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @param  accessOrder     the ordering mode - <tt>true</tt> for
 *         access-order, <tt>false</tt> for insertion-order
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}
  public V get(Object key) {
        Node<K,V> e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
}

```

​	通过上面我们可以发现accessOrder=true的时候 ，LinkedHashMap 中队列的顺序就是以访问的顺序排列的，get、put都会影响排列顺序。accessOrder=false的时候就是以插入循序排列的。

访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要，所以

```java
 * <p>This method typically does not modify the map in any way,
 * instead allowing the map to modify itself as directed by its
 * return value.  It <i>is</i> permitted for this method to modify
 * the map directly, but if it does so, it <i>must</i> return
 * <tt>false</tt> (indicating that the map should not attempt any
 * further modification).  The effects of returning <tt>true</tt>
 * after modifying the map from within this method are unspecified.
 *
 * <p>This implementation merely returns <tt>false</tt> (so that this
 * map acts like a normal map - the eldest element is never removed).
 *
 * @param    eldest The least recently inserted entry in the map, or if
 *           this is an access-ordered map, the least recently accessed
 *           entry.  This is the entry that will be removed it this
 *           method returns <tt>true</tt>.  If the map was empty prior
 *           to the <tt>put</tt> or <tt>putAll</tt> invocation resulting
 *           in this invocation, this will be the entry that was just
 *           inserted; in other words, if the map contains a single
 *           entry, the eldest entry is also the newest.
 * @return   <tt>true</tt> if the eldest entry should be removed
 *           from the map; <tt>false</tt> if it should be retained.
 */
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}

//在父类（HashMap）中的putVal的实现被回调。
void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }



```

```java
//实现，将被回调。当添加完后检查-----removeEldestEntry-----此重写的removeEldestEntry将会在每次添加的时候，判断是否删除最小的。
Map<K, V> cache = new
LinkedHashMap()(128, 0.75F, true)
{
	protected boolean removeEldestEntry(Map . Entry<K, V> eldest)
	{
		return size() > 100;
	}
}();
```



**枚举集与映射**

**标识散列映射**





### 7.4 视图和包装器





### 7.5 算法

​	跳过

### 7.6 遗留的集合

**Hashtable 类**

**枚举**

**属性映射**

**栈**

**位集**



























## 第八章 并发基础使用



### 8.1 什么是线程

### 8.2 中 断 线 程

### 8.3 线程状态

### 8.4 线 程 属 性

### 8.5 线 程 属 性

### 8.6 同 步

### 8.7 阻 塞 队 列

### 8.6 线程安全的集合

### 8.7 Callable 与 Future

### 8.8 执 行 器

### 8.9 同 步 器

### 8.10 线程与 Swing

