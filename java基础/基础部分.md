# java基础

## 第一章 java基本程序设计结构

### 1.1数据类型

java数据类型和java对象的区别

|   类别   |                             区别                             |
| :------: | :----------------------------------------------------------: |
| 数据类型 |          没有引用的概念，就是表示存储在内存上的数据          |
|   对象   | 需要来用存储在栈上的引用类型来指向，对象本身存储在堆上，引用类型存储的对象的地址相当于c++的指针。（后面详细介绍jvm内存模型） |

八种基本类型

|  类别   |    存储需求    |                 | 备注                                                         |      |
| :-----: | :------------: | :-------------: | ------------------------------------------------------------ | ---- |
|   int   |     4字节      |      整型       |                                                              |      |
|  short  |     2字节      |      整型       | 常应用于底层文件的处理                                       |      |
|  long   |     8字节      |      整型       |                                                              |      |
|  byte   |     1字节      |      整型       |                                                              |      |
|  float  |     4字节      |      浮点       |                                                              |      |
| double  |     8字节      |      浮点       | 三个特殊的浮点类型：正无穷大、负无穷大、<br />、NaN(不是一个数字) |      |
|  char   |     16bit      | 表示Unicode编码 |                                                              |      |
| boolean | 1bit（不知道） |                 |                                                              |      |

### 1.2 变量

| 值得注意的几个地方                                           |
| ------------------------------------------------------------ |
| 1.不能使用未初始化的变量                                     |
| 2.变量的声明尽量靠经第一次使用的地方                         |
| 3.常量要用final关键字，常量名最好大写，一生只能被赋值一次 。static final 用来定义类常量。 |
| 4.const 目前是java的保留字还未使用，常量必须使用final来声明。 |

### 1.3运算符

+、-、*、 / % 分别表示 加、减、乘、除、取余  结果的数据类型为参数的数据类型的范围最大的那个

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

### 1.4 字符串

java无内置字符串，标准类库提供了预定义类String （官方已经定义好的,非原生）。

<font color="red" >**每个用双引号括起来的字符串都是String类实例**</font>

1. **不可变**

   根据String源码发现，String对象没有修改自己数值的方法，只有生成字符串对象的方法（不改变自身对象的值）。

2. **String 常量共享**

   什么是String常量？只要是只要是用双引好包裹表示就相当于生成一个String常量。比如 String a=new String("abc"); 其实是生成了两个字符串常量一个是“abc”字符串常量对象； 另一个是值为“abc”的String对象；虽然它们两个的值相等的，但是他们不是一个对象。

   看下面代码：

   ```java
   		String strA = "112";
           String strB = "112";
           String strC = new String("112");
           String strD = "11" + "2";
           String a="11",b="2";String strE=a+b;
           String strF=a+"2";
           System.out.println("strA==strB:"+(strA==strB));
           System.out.println("strA==strC:"+(strA==strC));
           System.out.println("strA==strD:"+(strA==strD));
           System.out.println("strA==strE:"+(strA==strE));
           System.out.println("strA==strF:"+(strA==strF));
   ```

   打印结果

   ```text
   strA==strB:true
   strA==strC:false
   strA==strD:true
   strA==strE:false
   strA==strF:false
   ```

我们先来搞清楚== 和equals

<font color="red">**值比较？地址比较？**</font>

​			== 就是值比较，不过比较的值是引用类型的值，引用类型的值是什么？就是所指向对象的地址。例如：String a= new String("abc") 就是都这个函数返回一个引用类型的值赋给了 引用类型a; 

​		equals方法是对象的方法，只不过引用类型可以调用，进而可以比较他们指向对象的值。还有一点需要注意equals比较对象之间的值是否相等是根据对象的特性来写的。

strA==strB:true  引用类型指向同一个常量String 。所以他们同一个对象。

strA==strC:false 两个不同的对象 new String()不做共享变量

strA==strD:true 通过反编译可以看到这种写法与strA strB没有任何区别

strA==strE:false String strF=a+"2"; 字符串拼接 只要里面含有一个非常量，他就会生成一个非常量的String



咱们再在探究一下 new String("123"); 先看下面这段代码。

```java
		 char [] a={'a','c','d'}; char[] b=a;
         b[0]='A';System.out.println(a[0]);
```

打印结果

```text
A
```

说明数组也是一个对象，也就是可以用引用类型来指向。

再来看一下String 的new String方法

```java
  	public String(String original) {
        this.value = original.value; // private final char value[]; 
        this.hash = original.hash;  //private int hash; 
    }
```

也就说 this.value 和original.value 引用的是同一个数组对象。 所以说original不管所表示的字符串多大，只要它存在this的生成速度是极快，和大小没有影响。

3. **String注意要点**

 contact方法

```java
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}
```

concat方法的本质是生成一个新的String，从两个字符串中一个一个复制。这种方法不适合使用在连续向超大型字符串上拼接字符串。因为它会一个一个字符的复制到新的字符串上，极度浪费时间。”abc................................“.concat("a")， 这样循环几次就会极度浪费时间。

```java
String a="abc......"//超大字符串
while(有限次){
    a=a.concat("a")
}
```



上面的代码在有限的时间内运行不了几次



a+b的本质什么？ StringBuilder有什么弊端？ 小心StringBuilder的扩容机制导致内存溢出

4. **码点和代码单元**



5.**常用API**

|                        签名                         |                             解释                             |
| :-------------------------------------------------: | :----------------------------------------------------------: |
|               char charAt (int index)               | 返回给定位置的代码单元。除非对底层的代码单元感兴趣，<br />否则不需要调用这个方法。 |
|             int codePointAt(int Index)              |                  返回从给定位置开始的码点。                  |
| int offsetByCodePoints(int startlndex, int cpCount) |   返回从 startlndex 代码点开始位移 cpCount 后的码点索引。    |
|            int  compareTo(String other)             | 按照字典顺序如果字符串位于 other 之前，返回一个负数；如果字符串位于 <br />other 之后，返回一个正数； 如果两个字符串相等，返回 0。 |
|               IntStream codePoints()                | 将这个字符串的码点作为一个流返回。调用 toArray 将它们放在一个数组中。 |
| new String(int[] codePoints, int offset, int count) |    用数组中从 offset 开始的 count 个码点构造一个字符串。     |
|            boolean equals(0bject other)             |             如果字符串与 other 相等，返回 true。             |
|                        ....                         |                            .....                             |
|                  查看核心技术卷一                   |                                                              |

